{
  "@type": "NewsArticle",
  "identifier": "2022--03--07--en--myfeed--HackerNews--NewsArticle--30593532",
  "url": "https://news.ycombinator.com/item?id=30593532",
  "headline": "Some questions about computer architectures",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "Hi. Sorry for bad English, i'm from Germany. I'm developing my own instruction set architecture. I wanna ask advanced developers about possible pitfalls like slowdown or increased heat dissipation etc. in relation to arch described lower.\nSo, the main properties is: my instruction set uses SWAR approach - long common register, 256 bit wide, data is packed into bunches up to register width, and for every register-register instructions (except logical and bit twiddling) there are 4 different versions of them - 16, 32, 64 and 128 bits per unit of data, and so, 16/8/4/2 units per bunch. (It's not necessary to fill the registers completely, each register-register operation works &quot;separately&quot;, so, you just ignore higher bits, use only lower and later extract it as you need). Also, it's VLIW architecture - instructions itself are packed into bunches 256 bit wide. But here's the problem: instruction length is not fixed. (Also remember that in VLIW there are frequent NOP's, and it's big waste of memory).\nThe problem of data density is easy to solve - in my ISA there're also load/store instructions that loads or stores only small amounts of data (16, 32, 64 or 128 bit) instead of manipulating full bunches. But if i use the same approach to instruction bunches, i will need to introduce fetch meta-instructions. So, i came up with a different approach.\nFirstly, 256 bits are loaded into instruction register, starting at the address specified in the instruction pointer. First 4 bits of instruction bunch mean the amount of instructions in it. Next comes the opcode, based on which the length of instruction (with all registers/addresses/immediates) is computed. It repeat as many times as indicated in the first 4 bits of bunch. Other bits are ignored. After that, the instruction pointer increments to amount that is calculated from readed instructions, plus alignment. Bunches are aligned to fit into 16-bit memory cells. (My ISA uses 16 bit cells instead of 8).\nMy main questions: Wouldn't decoder be too complicated? Will it dissipate too much energy or not? What are the pitfalls regarding jump/interrupt instructions? And what do you personally think about this idea?",
  "keywords": [],
  "author": {
    "@type": "Person",
    "name": "hexatron",
    "url": "https://news.ycombinator.com/user?id=hexatron"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=30593532",
  "sameAs": "https://news.ycombinator.com/item?id=30593532",
  "dateCreated": "2022-03-07T22:10:15.778Z",
  "datePublished": "2022-03-07T21:26:53.000Z",
  "dateModified": "2022-03-07T22:10:15.778Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 1
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 0
    }
  ]
}