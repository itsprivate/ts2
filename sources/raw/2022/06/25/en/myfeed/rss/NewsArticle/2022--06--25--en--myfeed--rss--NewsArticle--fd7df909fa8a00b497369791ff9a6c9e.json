{
  "@type": "NewsArticle",
  "identifier": "2022--06--25--en--myfeed--rss--NewsArticle--fd7df909fa8a00b497369791ff9a6c9e",
  "url": "https://flak.tedunangst.com/post/reversing-an-openbsd-syspatch",
  "headline": "reversing an openbsd kernel syspatch",
  "publisher": {
    "@type": "Organization",
    "name": "flak.tedunangst.com",
    "url": "https://flak.tedunangst.com/rss"
  },
  "description": "OpenBSD has provided binary patches for a select few architectures for a while now, to save users from the daunting task of running make on their own. Alas, this means you might now apply a patch without first reviewing it. In the olden times, you had a source patch, so obviously you meticulously studied every line before application, just like you advised new users on IRC to do. But now, who will believe you do this when the binary syspatch is right there, so easy, so tempting.<p>Ah ha, you say, I will simply tell everyone that I inspect the binary files. Excellent idea. The binary syspatch should match the changes in the source patch; after all, it comes from the same place and you’re already trusting them with just about everything else, but you get extra internet points every time you say trust but verify. Let’s dig just deep enough that we might plausibly brag to our friends, that oh yes, we totally do this for every syspatch.<br><h3>syspatch</h3><p>First, we’ll need the syspatch. These aren’t actually linked anywhere on the website, since you aren’t supposed to need them, but it’s not particularly difficult to discover where they live. For this example, I’m using syspatch71-001_wifi.tgz for the <a href=\"https://www.openbsd.org/errata71.html\">7.1 001 wifi erratum</a>. Download that, then check its certificate of authenticity. Accept no substitutes.<p><pre><code>$ signify -C -x SHA256.sig syspatch71-001_wifi.tgz \nSignature Verified\nsyspatch71-001_wifi.tgz: OK</code></pre><p><code>tar tzf</code> reveals it’s just a bunch of files, located somewhere in <i>/usr</i>. There’s no special structure to a syspatch. It’s literally just files that get dropped into the file system. (There’s some backup and sanity checks in the <i>syspatch</i> script, of course, but the file doesn’t require much in the way of deep inspection.)<p>zxf, preferably in a directory other than /, and we’ve got some kernel objects to inspect.<br><h3>blowfish tartare</h3><p>Our inspection will probably go a bit smoother if we have something to compare with. On a live system, you’d just look at the files in <i>/usr</i>. But if we’re offline, or whatever, we need another copy. The files should be in the base71.tgz set, but I failed to find them on my first attempt. Had to a look a little closer to realize that the kernel object files are distributed in their own kernel.tgz file. Tarception!<p>I was all set to explain how to extract files from an inner tar without extracting the whole thing, but this does not appear possible with OpenBSD tar, even with fancy fd redirection. Side quest failed. If you install the <i>gtar</i> DLC, however, there is a -O option.<p>Anyway, you run tar twice, and we’re ready to compare files.<br><h3>vers.o</h3><p>I’ll start with a very simple file, and a very simple analysis tool. There was a <a href=\"https://marc.info/?l=openbsd-misc&amp;m=165068240031373&amp;w=2\">funny bug</a> in the first version of this syspatch where it would update the system into a nonupdateable state. A reasonable thing for us to double check. The binary syspatch <i>should</i> match the source patch, but sometimes it doesn’t. Trust, but verify.<p>I just ran <i>hexdump -C</i> and diffed the output.<p><pre><code><span class=dl>--- v0  Tue May 24 11:01:07 2022</span>\n<span class=al>+++ v1  Tue May 24 11:01:44 2022</span>\n<span class=bi>@@ -3,21 +3,21 @@</span>\n 00000020  00 00 00 00 00 00 00 00  f8 07 00 00 00 00 00 00  |................|\n 00000030  00 00 00 00 40 00 00 00  00 00 40 00 0c 00 01 00  |....@.....@.....|\n 00000040  4f 70 65 6e 42 53 44 00  37 2e 31 00 47 45 4e 45  |OpenBSD.7.1.GENE|\n<span class=dl>-00000050  52 49 43 2e 4d 50 23 34  36 35 00 00 00 00 00 00  |RIC.MP#465......|</span>\n<span class=al>+00000050  52 49 43 2e 4d 50 23 30  00 00 00 00 00 00 00 00  |RIC.MP#0........|</span>\n 00000060  20 20 20 20 40 28 23 29  4f 70 65 6e 42 53 44 20  |    @(#)OpenBSD |\n 00000070  37 2e 31 20 28 47 45 4e  45 52 49 43 2e 4d 50 29  |7.1 (GENERIC.MP)|\n<span class=dl>-00000080  20 23 34 36 35 3a 20 4d  6f 6e 20 41 70 72 20 31  | #465: Mon Apr 1|</span>\n<span class=dl>-00000090  31 20 31 38 3a 30 33 3a  35 37 20 4d 44 54 20 32  |1 18:03:57 MDT 2|</span>\n<span class=dl>-000000a0  30 32 32 0a 00 00 00 00  00 00 00 00 00 00 00 00  |022.............|</span>\n<span class=al>+00000080  20 23 30 3a 20 53 75 6e  20 41 70 72 20 32 34 20  | #0: Sun Apr 24 |</span>\n<span class=al>+00000090  30 39 3a 33 30 3a 34 33  20 4d 44 54 20 32 30 32  |09:30:43 MDT 202|</span>\n<span class=al>+000000a0  32 0a 00 00 00 00 00 00  00 00 00 00 00 00 00 00  |2...............|</span>\n 000000b0  4f 70 65 6e 42 53 44 20  37 2e 31 20 28 47 45 4e  |OpenBSD 7.1 (GEN|</code></pre><p>Sure enough, the build string has changed, but no changes to the status, like -stable. After that there’s a bit more.<p><pre><code><span class=bi>@@ -34,9 +34,9 @@</span>\n 00000360  00 00 00 01 01 09 09 03  00 00 00 00 00 00 00 00  |................|\n 00000370  03 40 00 00 00 04 4c 00  00 00 04 00 02 00 00 00  |.@....L.........|\n 00000380  00 8b 00 00 00 01 01 0a  09 03 00 00 00 00 00 00  |................|\n<span class=dl>-00000390  00 00 03 40 00 00 00 04  4c 00 00 00 0f 00 02 00  |...@....L.......|</span>\n<span class=al>+00000390  00 00 03 40 00 00 00 04  4c 00 00 00 0d 00 02 00  |...@....L.......|</span>\n 000003a0  00 00 00 ad 00 00 00 01  01 0b 09 03 00 00 00 00  |................|\n<span class=dl>-000003b0  00 00 00 00 03 40 00 00  00 04 4c 00 00 00 45 00  |.....@....L...E.|</span>\n<span class=al>+000003b0  00 00 00 00 03 40 00 00  00 04 4c 00 00 00 43 00  |.....@....L...C.|</span>\n 000003c0  02 00 00 00 00 cf 00 00  00 01 01 0d 09 03 00 00  |................|\n 000003d0  00 00 00 00 00 00 03 40  00 00 00 08 4c 00 00 00  |.......@....L...|\n 000003e0  00 02 00 00 4f 70 65 6e  42 53 44 20 63 6c 61 6e  |....OpenBSD clan|</code></pre><p>Hmm, a few more bytes have changed. Even a tiny change like switching a <i>je</i> to <i>jne</i> instruction could have catastrophic effects. In this case, I’m pretty sure the difference relates to the two byte difference in the previous string, but we may have exhausted the potential of hexdump here.<br><h3>what</h3><p>Moving on to a real file, <i>an.o</i>, diffing hexdumps is a disaster. We need something a little more intelligent like <i>objdump</i>. The regular output of objdump isn’t very amenable to diffing, either, because even tiny changes propagate throughout the file, affecting offsets everywhere. Nothing we can’t solve with a bit of code, though.<p>This seemed like an easy bit of <i>awk</i> to write, then I read the manual. Hexadecimal numbers convert to 0. This is even mentioned as a feature! Or a bug fix. Woe to those who’d like to process hexadecimal inputs.<p>Anyway, this isn’t hard. So I wrote a little utility called <i>what</i>. Where hides a trap? Basically...<p><pre><code>re_symbol <span class=op>:=</span> regexp<span class=op>.</span>MustCompile<span class=st>(</span><span class=st>`^([[:xdigit:]]+) &lt;(\\w+)&gt;:\\n$`</span><span class=st>)</span>\nre_insn <span class=op>:=</span> regexp<span class=op>.</span>MustCompile<span class=st>(</span><span class=st>`\\s+([[:xdigit:]]+):\\s*((?:[[:xdigit:]] ?)+)\\s*(.*)\\n$`</span><span class=st>)</span>\n<span class=kw>for</span> <span class=st>{</span>\n        line<span class=op>,</span> err <span class=op>:=</span> r<span class=op>.</span>ReadString<span class=kw>(</span><span class=nm>&#39;\\n&#39;</span><span class=kw>)</span>\n        <span class=kw>if</span> msym <span class=op>:=</span> re_symbol<span class=op>.</span>FindStringSubmatch<span class=kw>(</span>line<span class=kw>)</span>; <span class=bi>len</span><span class=kw>(</span>msym<span class=kw>)</span> <span class=op>&gt;</span> <span class=nm>0</span> <span class=kw>{</span>\n                symstart<span class=op>,</span> _ <span class=op>:=</span> strconv<span class=op>.</span>ParseInt<span class=cm>(</span>msym<span class=bi>[</span><span class=nm>1</span><span class=bi>]</span><span class=op>,</span> <span class=nm>16</span><span class=op>,</span> <span class=nm>0</span><span class=cm>)</span>\n                <span class=kw>for</span> <span class=cm>{</span>\n                        line<span class=op>,</span> err <span class=op>:=</span> r<span class=op>.</span>ReadString<span class=bi>(</span><span class=nm>&#39;\\n&#39;</span><span class=bi>)</span>\n                        <span class=kw>if</span> minsn <span class=op>:=</span> re_insn<span class=op>.</span>FindStringSubmatch<span class=bi>(</span>line<span class=bi>)</span>; <span class=bi>len</span><span class=bi>(</span>minsn<span class=bi>)</span> <span class=op>&gt;</span> <span class=nm>0</span> <span class=bi>{</span>\n                                addr<span class=op>,</span> _ <span class=op>:=</span> strconv<span class=op>.</span>ParseInt<span class=st>(</span>minsn<span class=kw>[</span><span class=nm>1</span><span class=kw>]</span><span class=op>,</span> <span class=nm>16</span><span class=op>,</span> <span class=nm>0</span><span class=st>)</span>\n                                offset <span class=op>:=</span> addr <span class=op>-</span> symstart\n                                decode <span class=op>:=</span> minsn<span class=st>[</span><span class=nm>3</span><span class=st>]</span>\n                                fmt<span class=op>.</span>Printf<span class=st>(</span><span class=st>&#34;insn 0x%x:\\t%s\\n&#34;</span><span class=op>,</span> offset<span class=op>,</span> decode<span class=st>)</span></code></pre><p>And now the output is mostly cleaned up. There’s a few cases where the offsets have changed, but not by much.<p><pre><code><span class=dl>-insn 0xe2:     je     1de6 &lt;an_txeof+0x106&gt;</span>\n<span class=al>+insn 0xe2:     je     1df6 &lt;an_txeof+0x106&gt;</span></code></pre><p>It’s funny that objdump knows we’re jumping to the same offset within the function, but still prints the fixed file offset, breaking our diff. Whatever.<p><pre><code>re_insnfixup <span class=op>:=</span> regexp<span class=op>.</span>MustCompile<span class=st>(</span><span class=st>`(callq?|jmpq?|ja|jb|jn?e|jge?|jn?s)\\s+([[:xdigit:]]+)`</span><span class=st>)</span>\n        <span class=kw>if</span> re_insnfixup<span class=op>.</span>MatchString<span class=st>(</span>decode<span class=st>)</span> <span class=st>{</span>\n                decode <span class=op>=</span> re_insnfixup<span class=op>.</span>ReplaceAllString<span class=kw>(</span>decode<span class=op>,</span> <span class=st>&#34;$1 xxx&#34;</span><span class=kw>)</span>\n        <span class=st>}</span></code></pre><p>More of the same.<p><pre><code><span class=dl>-insn 0x0:      mov    0(%rip),%r11        # 2fe7 &lt;an_set_nwkey+0x7&gt;</span>\n<span class=al>+insn 0x0:      mov    0(%rip),%r11        # 2ff7 &lt;an_set_nwkey+0x7&gt;</span></code></pre><p><pre><code>re_commentfixup <span class=op>:=</span> regexp<span class=op>.</span>MustCompile<span class=st>(</span><span class=st>`# ([[:xdigit:]]+)`</span><span class=st>)</span>\n        <span class=kw>if</span> re_commentfixup<span class=op>.</span>MatchString<span class=st>(</span>decode<span class=st>)</span> <span class=st>{</span>\n                decode <span class=op>=</span> re_commentfixup<span class=op>.</span>ReplaceAllString<span class=kw>(</span>decode<span class=op>,</span> <span class=st>&#34;# xxx&#34;</span><span class=kw>)</span>\n        <span class=st>}</span></code></pre><p>Okay, finally, getting some good results.<p><pre><code><span class=dl>-insn 0x36a:    mov    0x1(%rsi),%al</span>\n<span class=dl>-insn 0x36d:    test   $0x40,%al</span>\n<span class=dl>-insn 0x36f:    je xxx &lt;an_rxeof+0x37d&gt;</span>\n<span class=dl>-insn 0x371:    and    $0xbf,%al</span>\n<span class=dl>-insn 0x373:    mov    %al,0x1(%rsi)</span>\n<span class=dl>-insn 0x376:    orb    $0x1,0xfffffffffffffe80(%rbp)</span>\n<span class=dl>-insn 0x37d:    mov    %r14,%rdi</span>\n<span class=dl>-insn 0x380:    callq xxx &lt;an_rxeof+0x385&gt;</span>\n<span class=dl>-insn 0x385:    mov    %rax,%r12</span>\n<span class=dl>-insn 0x388:    movzbl 0xffffffffffffff89(%rbp),%eax</span>\n<span class=dl>-insn 0x38c:    mov    %eax,0xfffffffffffffe88(%rbp)</span>\n<span class=dl>-insn 0x392:    mov    0xffffffffffffff80(%rbp),%eax</span>\n<span class=dl>-insn 0x395:    mov    %eax,0xfffffffffffffe84(%rbp)</span>\n<span class=dl>-insn 0x39b:    lea    0xfffffffffffffe80(%rbp),%rcx</span>\n<span class=al>+insn 0x36b:    movq   $0x0,0xfffffffffffffe80(%rbp)</span>\n<span class=al>+insn 0x372:</span>\n<span class=al>+insn 0x376:    mov    0x1(%rsi),%al</span>\n<span class=al>+insn 0x379:    test   $0x40,%al</span>\n<span class=al>+insn 0x37b:    je xxx &lt;an_rxeof+0x389&gt;</span>\n<span class=al>+insn 0x37d:    and    $0xbf,%al</span>\n<span class=al>+insn 0x37f:    mov    %al,0x1(%rsi)</span>\n<span class=al>+insn 0x382:    orb    $0x1,0xfffffffffffffe80(%rbp)</span>\n<span class=al>+insn 0x389:    mov    %r14,%rdi</span>\n<span class=al>+insn 0x38c:    callq xxx &lt;an_rxeof+0x391&gt;</span>\n<span class=al>+insn 0x391:    mov    %rax,%r12</span>\n<span class=al>+insn 0x394:    movzbl 0xffffffffffffff89(%rbp),%eax</span>\n<span class=al>+insn 0x398:    mov    %eax,0xfffffffffffffe88(%rbp)</span>\n<span class=al>+insn 0x39e:    mov    0xffffffffffffff80(%rbp),%eax</span>\n<span class=al>+insn 0x3a1:    mov    %eax,0xfffffffffffffe84(%rbp)</span>\n<span class=al>+insn 0x3a7:    lea    0xfffffffffffffe80(%rbp),%rcx</span></code></pre><p>There’s the heart of the change. But still a fair bit noisy. It’s obvious most of the instructions are the same, but the offset change is still causing trouble. Smash it!<p><pre><code>offset <span class=op>=</span> <span class=nm>0</span></code></pre><p>And presto!<p><pre><code> insn 0x0:      callq xxx &lt;an_rxeof+0x358&gt;\n insn 0x0:      add    $0x48,%r14\n insn 0x0:      mov    0x10(%r15),%rsi\n<span class=dl>-insn 0x0:      movl   $0x0,0xfffffffffffffe80(%rbp)</span>\n<span class=al>+insn 0x0:      movq   $0x0,0xfffffffffffffe88(%rbp)</span>\n insn 0x0:\n<span class=al>+insn 0x0:      movq   $0x0,0xfffffffffffffe80(%rbp)</span>\n<span class=al>+insn 0x0:</span>\n insn 0x0:      mov    0x1(%rsi),%al\n insn 0x0:      test   $0x40,%al</code></pre><p>That looks like a pretty reasonable assembly change for the source patch.<p><pre><code><span class=dl>--- sys/dev/ic/an.c\t25 Feb 2021 02:48:20 -0000\t1.78</span>\n<span class=al>+++ sys/dev/ic/an.c\t21 Apr 2022 22:24:17 -0000</span>\n<span class=bi>@@ -462,7 +462,7 @@ an_rxeof(struct an_softc *sc)</span>\n #endif /* NBPFILTER &gt; 0 */\n \n \twh = mtod(m, struct ieee80211_frame *);\n<span class=dl>-\trxi.rxi_flags = 0;</span>\n<span class=al>+\tmemset(&amp;rxi, 0, sizeof(rxi));</span>\n \tif (wh-&gt;i_fc[1] &amp; IEEE80211_FC1_WEP) {\n \t\t/*\n \t\t * WEP is decrypted by hardware. Clear WEP bit</code></pre><p>Whew! Now just need to repeat that for the 64 remaining files.<br><h3>wrap up</h3><p>If I thought about it, preserving the offset was never necessary for this approach. I was imagining we’d need some more sophisticated processing. And maybe we would for a more complicated change. There’s a reason I selected a very simple patch, although it’s a nice showcase of how kernel patches are distributed. Maybe next time we’ll try using a tool that’s actually designed for binary analysis and forensics instead of banging magnetic rocks together.<p>Having realized how simple the task is, I leave you with this sed liner.<p><pre><code>function sedit { sed -E -e &#39;s/^[[:xdigit:]]+ &lt;/&lt;/&#39; -e &#39;s/^ *[[:xdigit:]]+:([[:space:]][[:xdigit:]]{2})* *//&#39; -e &#39;s/(callq?|jmpq?|ja|jb|jn?e|jge?|jn?s) +([[:xdigit:]]+)/$1/&#39; -e &#39;s/# ([[:xdigit:]]+)//&#39;; }; objdump -d base/usr/share/relink/kernel/GENERIC.MP/an.o | sedit | (exec 3&lt; /dev/stdin; objdump -d 001/usr/share/relink/kernel/GENERIC.MP/an.o | sedit | diff -u /dev/fd/3 -;)</code></pre><p>You know it’s good because it even ends with smiley.",
  "keywords": [],
  "author": {
    "@type": "Person",
    "name": "unknown",
    "url": "https://flak.tedunangst.com/rss"
  },
  "discussionUrl": "https://flak.tedunangst.com/post/reversing-an-openbsd-syspatch",
  "sameAs": "https://flak.tedunangst.com/post/reversing-an-openbsd-syspatch",
  "dateCreated": "2022-06-25T16:34:56.216Z",
  "datePublished": "2022-05-25T08:38:53.000Z",
  "dateModified": "2022-06-25T16:34:56.216Z",
  "interactionStatistic": []
}