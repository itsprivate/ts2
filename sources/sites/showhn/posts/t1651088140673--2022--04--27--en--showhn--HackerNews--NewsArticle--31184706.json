{
  "@type": "NewsArticle",
  "identifier": "2022--04--27--en--showhn--HackerNews--NewsArticle--31184706",
  "url": "https://news.ycombinator.com/item?id=31184706",
  "headline": "Show HN: New Pathfinding Algorithm",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "Hello HN,<p>I am creating a city builder video game and wanted to figure out a way to efficiently and realistically path hundreds of thousands of agents around the game world, with path preferences that the agents can utilize (such as wanting to walk through china town on their way to their destination)<p>If you're not aware, algorithms like Dijkstra and A* will only return one shortest path between two points, which is not very realistic when you're walking around e.g. Manhattan, NYC and have a binomial coefficient number of possible paths to choose from. The other limitation is that these algorithms wont factor in path preferences (might not be entirely true for A*).<p>So I created an algorithm that can cache all possible shortest paths between two points in N space (so all node pairs cached is N^2 space). Additionally, I figured out a way to store the data in a (C++) vector and maintain constant find/access time, since hash tables have a lot of memory overhead.<p>I wrote up an introduction article (with video proof at the end, though it's my first YouTube video so bear with me ha ha) that will be followed by a technical one when I have time.<p>If you have any tips on how I can put the algorithm through the ringer, and how I could create a white paper if successful, I would greatly appreciate it! I don't have any academic connections so I'm not sure who I could reach out to professionally.<p>Link: https://www.yesboxstudios.com/2022/04/27/all-nck-shortest-paths-in-near-optimal-time-and-space-complexity-introduction/",
  "keywords": [
    "Show HN"
  ],
  "genre": "Show HN",
  "author": {
    "@type": "Person",
    "name": "YesBox",
    "url": "https://news.ycombinator.com/user?id=YesBox"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=31184706",
  "sameAs": "https://news.ycombinator.com/item?id=31184706",
  "dateCreated": "2022-04-27T19:35:40.673Z",
  "datePublished": "2022-04-27T19:34:14.000Z",
  "dateModified": "2022-04-27T19:35:40.673Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 1
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 0
    }
  ],
  "headline_zh-Hans": "Show HN: 新的寻路算法",
  "headline_zh-Hant": "Show HN: 新的尋路算法",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "Hello HN,<p>我正在创建一个城市建设的视频游戏，并希望找出一种方法来有效和现实地引导数十万代理人在游戏世界中行走，并有代理人可以利用的路径偏好（例如希望在前往目的地的路上穿过中国城）<p>如果你不知道，像Dijkstra和A*这样的算法只会返回两点之间的一条最短路径，这在你四处行走时并不现实。 例如，在纽约市曼哈顿，有二项式系数的可能路径可供选择。另一个限制是，这些算法不会考虑路径偏好的因素（对A*来说可能不完全正确）。<p>所以我创建了一个算法，可以在N个空间内缓存两点之间所有可能的最短路径（所以所有节点对的缓存是N^2空间）。此外，我想出了一种方法，可以将数据存储在一个（C++）矢量中，并保持恒定的查找/访问时间，因为哈希表有大量的内存开销。<p>我写了一篇介绍文章（最后有视频证明，虽然这是我第一次在YouTube上看视频，但请忍耐一下哈），有时间的话会写一篇技术文章。<p>如果你对我如何将该算法进行测试，以及如果成功的话我如何创作白皮书有任何建议，我将非常感激! 我没有任何学术上的联系，所以我不知道在专业上可以联系到谁。<p>链接：https://www.yesboxstudios.com/2022/04/27/all-nck-shortest-paths-in-near-optimal-time-and-space-complexity-introduction/",
  "description_zh-Hant": "Hello HN,<p>我正在創建一個城市建設的視頻遊戲，並希望找出一種方法來有效和現實地引導數十萬代理人在遊戲世界中行走，並有代理人可以利用的路徑偏好（例如希望在前往目的地的路上穿過中國城）<p>如果你不知道，像Dijkstra和A*這樣的算法只會返回兩點之間的一條最短路徑，這在你四處行走時並不現實。 例如，在紐約市曼哈頓，有二項式係數的可能路徑可供選擇。另一個限制是，這些算法不會考慮路徑偏好的因素（對A*來說可能不完全正確）。<p>所以我創建了一個算法，可以在N個空間內緩存兩點之間所有可能的最短路徑（所以所有節點對的緩存是N^2空間）。此外，我想出了一種方法，可以將數據存儲在一個（C++）矢量中，並保持恆定的查找/訪問時間，因為哈希表有大量的內存開銷。<p>我寫了一篇介紹文章（最後有視頻證明，雖然這是我第一次在YouTube上看視頻，但請忍耐一下哈），有時間的話會寫一篇技術文章。<p>如果你對我如何將該算法進行測試，以及如果成功的話我如何創作白皮書有任何建議，我將非常感激! 我沒有任何學術上的聯繫，所以我不知道在專業上可以聯繫到誰。<p>鏈接：https://www.yesboxstudios.com/2022/04/27/all-nck-shortest-paths-in-near-optimal-time-and-space-complexity-introduction/"
}