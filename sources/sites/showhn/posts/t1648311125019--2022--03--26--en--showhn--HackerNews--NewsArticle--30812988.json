{
  "@type": "NewsArticle",
  "identifier": "2022--03--26--en--showhn--HackerNews--NewsArticle--30812988",
  "url": "https://news.ycombinator.com/item?id=30812988",
  "headline": "Show HN: Wachy – A UI for eBPF-based performance debugging",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "eBPF is an amazing technology that allows safely running user-supplied functions at pretty much arbitrary probe points in a kernel/user space context. Much has been written about how amazing this feature is for kernel observability. But as someone who writes user space code, what I find even more amazing is the support for tracing arbitrary user space programs, with no code changes and low overhead.<p>However, doing in-depth analysis can get complicated and time-consuming. My goal with wachy was to make this debugging significantly easier/faster to use, by displaying traces in a TUI next to the source code and allowing for interactive drilldown analysis. If you get a chance, check out the start of the demo video since (AFAIK) it's quite unique and gives a much clearer idea than I can provide with just text.",
  "keywords": [
    "Show HN"
  ],
  "genre": "Show HN",
  "author": {
    "@type": "Person",
    "name": "vivek-jain",
    "url": "https://news.ycombinator.com/user?id=vivek-jain"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=30812988",
  "sameAs": "https://rubrikinc.github.io/wachy/",
  "dateCreated": "2022-03-26T16:12:05.019Z",
  "datePublished": "2022-03-26T15:59:23.000Z",
  "dateModified": "2022-03-26T16:12:05.019Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 2
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 0
    }
  ],
  "headline_zh-Hans": "Show HN: Wachy - 一个基于eBPF的性能调试的用户界面",
  "headline_zh-Hant": "Show HN: Wachy - 一個基於eBPF的性能調試的用戶界面",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "eBPF是一项了不起的技术，它允许在内核/用户空间的上下文中，在几乎任意的探测点上安全地运行用户提供的函数。关于这个功能对内核可观察性有多大的作用，已经写了很多。但是，作为一个编写用户空间代码的人，我发现更令人惊讶的是，它支持追踪任意的用户空间程序，而且不需要修改代码，开销也很低。<p>然而，进行深入分析可能会变得复杂和耗时。我对wachy的目标是通过在源代码旁边的TUI中显示跟踪，并允许进行交互式的深入分析，使这种调试明显地更容易/更快使用。如果你有机会，可以看看演示视频的开头，因为（AFAIK）它非常独特，比我只用文字就能提供一个更清晰的概念。",
  "description_zh-Hant": "eBPF是一項了不起的技術，它允許在內核/用戶空間的上下文中，在幾乎任意的探測點上安全地運行用戶提供的函數。關於這個功能對內核可觀察性有多大的作用，已經寫了很多。但是，作為一個編寫用戶空間代碼的人，我發現更令人驚訝的是，它支持追蹤任意的用戶空間程序，而且不需要修改代碼，開銷也很低。<p>然而，進行深入分析可能會變得複雜和耗時。我對wachy的目標是通過在源代碼旁邊的TUI中顯示跟蹤，並允許進行交互式的深入分析，使這種調試明顯地更容易/更快使用。如果你有機會，可以看看演示視頻的開頭，因為（AFAIK）它非常獨特，比我只用文字就能提供一個更清晰的概念。"
}