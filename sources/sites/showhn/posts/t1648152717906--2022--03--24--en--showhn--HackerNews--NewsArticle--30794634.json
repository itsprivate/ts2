{
  "@type": "NewsArticle",
  "identifier": "2022--03--24--en--showhn--HackerNews--NewsArticle--30794634",
  "url": "https://news.ycombinator.com/item?id=30794634",
  "headline": "Show HN: Daggyr DAG Work Orchestration Engine",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "Hello all,<p><pre><code>  I've been seeing a lot of interest in work orchestration frameworks, and thought I'd show off my own take. It's the project I've used to learn rust (entire project is async rust using tokio and actix), but it's been really useful for my main work, too.\n\n  Daggyr is an engine for executing tasks as quickly as possible. It can run tasks on flexible back-ends (slurm, local threads, etc), and report updates / events to trackers (currently only in-memory, working on postgres and mongodb).\n\n  There's no UI, just a REST interface. It doesn't do scheduling (there are tons of tools for that). It doesn't currently have multiple users / auth, but I'm working on that.\n\n  It does support pipelines defined in JSON, task parameterization, a very simple and fast REST interface for job submission and tracking, and resuming failed runs from where they left off.\n\n  Why another one of these things?\n</code></pre>\n1. I couldn't get behind Airflow's weird scheduling opinions.<p>2. Dagster, Airflow, and Prefect rely on tight integration with python. A lot of my work flows are calling custom binaries, so python provides no value, and it's also a barrier to defining jobs.<p>3. Daggyr can scale to pipelines of hundreds of thousands of tasks.<p>4. Daggyr is stupidly simple to run: no external services or dependencies (unless you want them). Simple run the binary and send some work.<p><pre><code>  Long story short, it does what it says on the tin, but there's more work to be done. I'd really appreciate any feedback. No idea if I'm going to try and commercialize it, but if you'd like to see  a feature ASAP, I'm always open to sponsored feature development!\n</code></pre>\nedit: formatting",
  "keywords": [
    "Show HN"
  ],
  "genre": "Show HN",
  "author": {
    "@type": "Person",
    "name": "iroddis",
    "url": "https://news.ycombinator.com/user?id=iroddis"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=30794634",
  "sameAs": "https://github.com/kinesintech/daggyr",
  "dateCreated": "2022-03-24T20:11:57.906Z",
  "datePublished": "2022-03-24T19:57:34.000Z",
  "dateModified": "2022-03-24T20:11:57.906Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 1
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 0
    }
  ],
  "headline_zh-Hans": "Show HN: Daggyr DAG工作协调引擎",
  "headline_zh-Hant": "Show HN: Daggyr DAG工作協調引擎",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "大家好，<p><pre><code>我看到很多人对工作协调框架感兴趣，我想我应该展示一下自己的想法。这是我用来学习rust的项目（整个项目是使用tokio和actix的async rust），但它对我的主要工作也非常有用。\n\n  Daggyr是一个尽可能快地执行任务的引擎。它可以在灵活的后端（slurm、本地线程等）上运行任务，并向跟踪器报告更新/事件（目前只有内存，在postgres和mongodb上工作）。\n\n  没有用户界面，只有一个REST接口。它不做调度（有大量的工具可以做）。它目前没有多用户/认证，但我正在努力实现。\n\n  它确实支持用JSON定义的管道，任务参数化，一个非常简单和快速的REST接口，用于作业提交和跟踪，以及从失败的地方恢复运行。\n\n  Why another one of these things?\n</code></pre>\n1. I couldn't get behind Airflow's weird scheduling opinions.<p>2. Dagster, Airflow, and Prefect rely on tight integration with python. A lot of my work flows are calling custom binaries, so python provides no value, and it's also a barrier to defining jobs.<p>3. Daggyr can scale to pipelines of hundreds of thousands of tasks.<p>4. Daggyr is stupidly simple to run: no external services or dependencies (unless you want them). Simple run the binary and send some work.<p><pre><code> Long story short, it does what it says on the tin, but there's more work to be done. I'd really appreciate any feedback. No idea if I'm going to try and commercialize it, but if you'd like to see a feature ASAP, I'm always open to sponsored feature development!\n</code></pre>\nedit: formatting",
  "description_zh-Hant": "大家好，<p><pre><code>我看到很多人對工作協調框架感興趣，我想我應該展示一下自己的想法。這是我用來學習rust的項目（整個項目是使用tokio和actix的async rust），但它對我的主要工作也非常有用。\n\n  Daggyr是一個儘可能快地執行任務的引擎。它可以在靈活的後端（slurm、本地線程等）上運行任務，並向跟蹤器報告更新/事件（目前只有內存，在postgres和mongodb上工作）。\n\n  沒有用戶界面，只有一個REST接口。它不做調度（有大量的工具可以做）。它目前沒有多用戶/認證，但我正在努力實現。\n\n  它確實支持用JSON定義的管道，任務參數化，一個非常簡單和快速的REST接口，用於作業提交和跟蹤，以及從失敗的地方恢復運行。\n\n  Why another one of these things?\n</code></pre>\n1. I couldn't get behind Airflow's weird scheduling opinions.<p>2. Dagster, Airflow, and Prefect rely on tight integration with python. A lot of my work flows are calling custom binaries, so python provides no value, and it's also a barrier to defining jobs.<p>3. Daggyr can scale to pipelines of hundreds of thousands of tasks.<p>4. Daggyr is stupidly simple to run: no external services or dependencies (unless you want them). Simple run the binary and send some work.<p><pre><code> Long story short, it does what it says on the tin, but there's more work to be done. I'd really appreciate any feedback. No idea if I'm going to try and commercialize it, but if you'd like to see a feature ASAP, I'm always open to sponsored feature development!\n</code></pre>\nedit: formatting"
}