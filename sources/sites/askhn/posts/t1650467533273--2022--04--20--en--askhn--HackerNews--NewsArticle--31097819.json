{
  "@type": "NewsArticle",
  "identifier": "2022--04--20--en--askhn--HackerNews--NewsArticle--31097819",
  "url": "https://news.ycombinator.com/item?id=31097819",
  "headline": "Ask HN: DB Migration and Deployment Race Strategy",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "For the last few months, we've been running our database migrations using Go and Goose [1] within our Github Actions workflows as a step that completes after a successful asset deployment. For the sake of the post, assume that the deployed &quot;thing&quot; is a lambda function. Installing Go and Goose for each deployment run costs us about a minute and a half, to two minutes, depending on Github Actions' mood that day. It's a chunk that I'd like to remove from our deployment runs, as maybe 1 out of every 100 deployments has a database migration in tow. Separating the db migrations and Go/Goose installs into a separate job that runs based on whether or not the migrations directory has changes, dependent on the deployment job (or vise versa), seems like a good way to go. However, that presents some race conditions and there doesn't seem to be much (that I could find) written on best practices for this scenario. Here are the conditions I've come up with:<p>1. if a migration is run first, then the current thing running against the db could start erroring<p>2. if a migration is run first, and the deployment fails, a migrate down needs to be immediately performed, the current thing errors until done<p>3. if a migration is run last, then the new deployed thing could error for a hot moment while migration is running<p>4. if a migration is run last and fails, then the new deployed thing could error until the migration is fixed<p>Presently, we're taking the latter approach in running migrations last. We haven't hit any snags there... yet. But the team is small and I'm trying to plan around eventual expansion. What does HN think?<p>[1] https://github.com/pressly/goose",
  "keywords": [
    "Ask HN"
  ],
  "genre": "Ask HN",
  "author": {
    "@type": "Person",
    "name": "andrew_",
    "url": "https://news.ycombinator.com/user?id=andrew_"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=31097819",
  "sameAs": "https://news.ycombinator.com/item?id=31097819",
  "dateCreated": "2022-04-20T15:12:13.273Z",
  "datePublished": "2022-04-20T14:53:45.000Z",
  "dateModified": "2022-04-20T15:12:13.273Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 1
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 0
    }
  ],
  "headline_zh-Hans": "Ask HN: DB迁移和部署竞赛策略",
  "headline_zh-Hant": "Ask HN: DB遷移和部署競賽策略",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "在过去的几个月里，我们一直在Github Actions工作流程中使用Go和Goose[1]运行我们的数据库迁移，作为成功部署资产后完成的一个步骤。在这篇文章中，假设部署的&quot;thing&quot;是一个lambda函数。为每次部署运行安装Go和Goose要花费我们大约一分半到两分钟，这取决于Github Actions当天的心情。这是我想从我们的部署运行中移除的一大块，因为每100次部署中可能就有一次数据库迁移。把数据库迁移和Go/Goose安装分离成一个单独的工作，根据迁移目录是否有变化来运行，取决于部署工作（或反之亦然），这似乎是一个好办法。然而，这就产生了一些竞争条件，而且似乎没有多少（我可以找到的）关于这种情况下的最佳做法的文章。以下是我想到的情况：<p>1.如果先运行迁移，那么当前针对数据库运行的程序可能会开始出错<p>2.如果先运行迁移，而部署失败，则需要立即执行迁移，当前程序会出错，直到完成为止<p>3.如果先运行迁移，而部署失败，则需要立即执行迁移。如果迁移是最后进行的，那么在迁移运行的过程中，新部署的东西可能会出错<p>4。 如果迁移是最后进行的，并且失败了，那么新部署的东西可能会出错，直到迁移被修复<p>目前，我们采取的是后一种方法，最后进行迁移。我们还没有遇到任何障碍......还没有。但我们的团队很小，我正在努力计划最终的扩展。HN是怎么想的？<p>[1] https://github.com/pressly/goose",
  "description_zh-Hant": "在過去的幾個月裡，我們一直在Github Actions工作流程中使用Go和Goose[1]運行我們的數據庫遷移，作為成功部署資產後完成的一個步驟。在這篇文章中，假設部署的&quot;thing&quot;是一個lambda函數。為每次部署運行安裝Go和Goose要花費我們大約一分半到兩分鐘，這取決於Github Actions當天的心情。這是我想從我們的部署運行中移除的一大塊，因為每100次部署中可能就有一次數據庫遷移。把數據庫遷移和Go/Goose安裝分離成一個單獨的工作，根據遷移目錄是否有變化來運行，取決於部署工作（或反之亦然），這似乎是一個好辦法。然而，這就產生了一些競爭條件，而且似乎沒有多少（我可以找到的）關於這種情況下的最佳做法的文章。以下是我想到的情況：<p>1.如果先運行遷移，那麼當前針對數據庫運行的程序可能會開始出錯<p>2.如果先運行遷移，而部署失敗，則需要立即執行遷移，當前程序會出錯，直到完成為止<p>3.如果先運行遷移，而部署失敗，則需要立即執行遷移。如果遷移是最後進行的，那麼在遷移運行的過程中，新部署的東西可能會出錯<p>4。 如果遷移是最後進行的，並且失敗了，那麼新部署的東西可能會出錯，直到遷移被修復<p>目前，我們採取的是後一種方法，最後進行遷移。我們還沒有遇到任何障礙......還沒有。但我們的團隊很小，我正在努力計劃最終的擴展。HN是怎麼想的？<p>[1] https://github.com/pressly/goose"
}