{
  "@type": "NewsArticle",
  "identifier": "2022--07--09--en--askhn--HackerNews--NewsArticle--32030553",
  "url": "https://news.ycombinator.com/item?id=32030553",
  "headline": "Ask HN: What programming languages distinguish between “old” and “new” values?",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "Suppose I have this trivial C++ program:<p><pre><code>  #include &lt;stdio.h&gt;\n\n  int a = 0;\n  int b = 0;\n\n  void update_state() {\n    a = b + 1;\n    b = a + 1;\n  }\n\n  int main() {\n    for (int i = 0; i &lt; 3; i++) {\n      update_state();\n      printf(&quot;%d %d\\n&quot;, a, b);  \n    }\n    return 0;\n  }\n</code></pre>\nThis will print<p><pre><code>  1 2\n  3 4\n  5 6\n</code></pre>\nwhich shouldn't be too surprising. What it does _not_ print is:<p><pre><code>  1 1\n  2 2\n  3 3\n</code></pre>\nbecause &quot;b = a + 1&quot; is reading the &quot;new&quot; value of A, not the &quot;old&quot; value as you might expect if you were a new programmer just skimming through the source. If we wanted that behavior we could write<p><pre><code>  void update() {\n    int a_old = a;\n    int b_old = b;\n    a = b_old + 1;\n    b = a_old + 1;\n  }\n</code></pre>\nor<p><pre><code>  void update() {\n    int a_new = b + 1;\n    int b_new = a + 1;\n    a = a_new;\n    b = b_new;\n  }\n</code></pre>\nbut in both cases we have to introduce new temporary variables to hold a copy of either the &quot;old&quot; or &quot;new&quot; state so we don't clobber one of them. If we could annotate our variable names with &quot;oldness&quot; and &quot;newness&quot; we could write something like this:<p><pre><code>  void update() {\n    a_new = b_old + 1;\n    b_new = a_old + 1;\n  }\n</code></pre>\nBut that won't work in plain C because &quot;_old&quot; and &quot;_new&quot; aren't meaningful suffixes. More importantly, we can't realistically implement <i>any</i> way of explicitly distinguishing between old and new values in C++ at all - classes and templates don't quite give us enough flexibility to do so.<p>In this trivial example it's easy to see why the different update() methods produce different results, but in large systems it's surprisingly easy to introduce subtle bugs by changing the order of function calls : ClassA expects to read some &quot;new&quot; state from ClassB, code gets refactored, ClassA now inadvertently reads &quot;old&quot; state from ClassB, everything appears to work fine until one day a timing issue causes ClassA and ClassB to get out of sync and everything blows up.<p>After looking around at existing programming languages (and some CS papers from Google Scholar), it doesn't appear that any major programming languages support this sort of annotation. The closest you can get is the &quot;&lt;=&quot; operator in Verilog, which means something like &quot;assign the RHS to the LHS, but don't do it yet - do it after the current simulation step is done running&quot;.<p>I feel like this is probably a thoroughly covered topic already, but my research skills are failing to turn up anything relevant. Is there some computer sciencey term I'm unaware of to describe languages that allow for these sorts of old/new distinctions?",
  "keywords": [
    "Ask HN"
  ],
  "genre": "Ask HN",
  "author": {
    "@type": "Person",
    "name": "aappleby",
    "url": "https://news.ycombinator.com/user?id=aappleby"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=32030553",
  "sameAs": "https://news.ycombinator.com/item?id=32030553",
  "dateCreated": "2022-07-09T02:10:55.644Z",
  "datePublished": "2022-07-09T01:54:30.000Z",
  "dateModified": "2022-07-09T02:10:55.644Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 1
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 1
    }
  ],
  "headline_zh-Hans": "Ask HN: 哪些编程语言会区分 \"旧 \"和 \"新 \"价值？\n",
  "headline_zh-Hant": "Ask HN: 哪些編程語言會區分 \"舊 \"和 \"新 \"價值？\n",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "Suppose I have this trivial C++ program:<p><pre><code> #include &lt;stdio.h&gt;\n\n  int a = 0;\n  int b = 0;\n\n  void update_state() {\n    a = b + 1;\n    b = a + 1;\n  }\n\n  int main() {\n    for (int i = 0; i &lt; 3; i++) {\n      update_state();\n      printf(&quot;%d %d\\n&quot;, a, b);  \n    }\n    return 0;\n  }\n</code></pre>\nThis will print<p><pre><code> 1 2\n  3 4\n  5 6\n</code></pre>\nwhich shouldn't be too surprising. What it does _not_ print is:<p><pre><code> 1 1\n  2 2\n  3 3\n</code></pre>\nbecause &quot;b = a + 1&quot; is reading the &quot;new&quot; value of A, not the &quot;old&quot; value as you might expect if you were a new programmer just skimming through the source. If we wanted that behavior we could write<p><pre><code> void update() {\n    int a_old = a;\n    int b_old = b;\n    a = b_old + 1;\n    b = a_old + 1;\n  }\n</code></pre>\nor<p><pre><code> void update() {\n    int a_new = b + 1;\n    int b_new = a + 1;\n    a = a_new;\n    b = b_new;\n  }\n</code></pre>\nbut in both cases we have to introduce new temporary variables to hold a copy of either the &quot;old&quot; or &quot;new&quot; state so we don't clobber one of them. If we could annotate our variable names with &quot;oldness&quot; and &quot;newness&quot; we could write something like this:<p><pre><code> void update() {\n    a_new = b_old + 1;\n    b_new = a_old + 1;\n  }\n</code></pre>\nBut that won't work in plain C because &quot;_old&quot; and &quot;_new&quot; aren't meaningful suffixes. More importantly, we can't realistically implement <i>any</i> way of explicitly distinguishing between old and new values in C++ at all - classes and templates don't quite give us enough flexibility to do so. <p>In this trivial example it's easy to see why the different update() methods produce different results, but in large systems it's surprisingly easy to introduce subtle bugs by changing the order of function calls : ClassA expects to read some &quot;new&quot; state from ClassB, code gets refactored, ClassA now inadvertently reads &quot;old&quot; state from ClassB, everything appears to work fine until one day a timing issue causes ClassA and ClassB to get out of sync and everything blows up. <p>After looking around at existing programming languages (and some CS papers from Google Scholar), it doesn't appear that any major programming languages support this sort of annotation. 最接近的是Verilog中的&quot;&lt;=&quot;操作符，意思是&quot;将RHS分配给LHS，但先不要做--在当前仿真步骤运行完毕后再做&quot;。<p>我觉得这可能是一个已经被彻底覆盖的话题，但我的研究技能却无法找到任何相关内容。是否有一些我不知道的计算机科学术语来描述允许这些新旧区分的语言？\n",
  "description_zh-Hant": "Suppose I have this trivial C++ program:<p><pre><code> #include &lt;stdio.h&gt;\n\n  int a = 0;\n  int b = 0;\n\n  void update_state() {\n    a = b + 1;\n    b = a + 1;\n  }\n\n  int main() {\n    for (int i = 0; i &lt; 3; i++) {\n      update_state();\n      printf(&quot;%d %d\\n&quot;, a, b);  \n    }\n    return 0;\n  }\n</code></pre>\nThis will print<p><pre><code> 1 2\n  3 4\n  5 6\n</code></pre>\nwhich shouldn't be too surprising. What it does _not_ print is:<p><pre><code> 1 1\n  2 2\n  3 3\n</code></pre>\nbecause &quot;b = a + 1&quot; is reading the &quot;new&quot; value of A, not the &quot;old&quot; value as you might expect if you were a new programmer just skimming through the source. If we wanted that behavior we could write<p><pre><code> void update() {\n    int a_old = a;\n    int b_old = b;\n    a = b_old + 1;\n    b = a_old + 1;\n  }\n</code></pre>\nor<p><pre><code> void update() {\n    int a_new = b + 1;\n    int b_new = a + 1;\n    a = a_new;\n    b = b_new;\n  }\n</code></pre>\nbut in both cases we have to introduce new temporary variables to hold a copy of either the &quot;old&quot; or &quot;new&quot; state so we don't clobber one of them. If we could annotate our variable names with &quot;oldness&quot; and &quot;newness&quot; we could write something like this:<p><pre><code> void update() {\n    a_new = b_old + 1;\n    b_new = a_old + 1;\n  }\n</code></pre>\nBut that won't work in plain C because &quot;_old&quot; and &quot;_new&quot; aren't meaningful suffixes. More importantly, we can't realistically implement <i>any</i> way of explicitly distinguishing between old and new values in C++ at all - classes and templates don't quite give us enough flexibility to do so. <p>In this trivial example it's easy to see why the different update() methods produce different results, but in large systems it's surprisingly easy to introduce subtle bugs by changing the order of function calls : ClassA expects to read some &quot;new&quot; state from ClassB, code gets refactored, ClassA now inadvertently reads &quot;old&quot; state from ClassB, everything appears to work fine until one day a timing issue causes ClassA and ClassB to get out of sync and everything blows up. <p>After looking around at existing programming languages (and some CS papers from Google Scholar), it doesn't appear that any major programming languages support this sort of annotation. 最接近的是Verilog中的&quot;&lt;=&quot;操作符，意思是&quot;將RHS分配給LHS，但先不要做--在當前仿真步驟運行完畢後再做&quot;。<p>我覺得這可能是一個已經被徹底覆蓋的話題，但我的研究技能卻無法找到任何相關內容。是否有一些我不知道的計算機科學術語來描述允許這些新舊區分的語言？\n"
}