{
  "@type": "NewsArticle",
  "identifier": "2022--07--22--en--askhn--HackerNews--NewsArticle--32193017",
  "url": "https://news.ycombinator.com/item?id=32193017",
  "headline": "Ask HN: Any name/metaphor for this particular kind of entropy / tech debt?",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "One thing I have seen over and over again in many organizations is that a new product is designed and implemented from scratch, using a fairly logical and sensible structure / architecture.<p>For example, maybe there is a frontend that connects to three separate backend servers, A, B, and C, which all handle some different, self-contained logical thing. Or maybe things are divided into key classes A, B and C, each of which encapsulates a self-contained piece of functionality. It's possible for A or B to fail without affecting C. If B crashes, you know it is due to a problem with some particular feature. It's all quite sensible and easy to reason about.<p>Then, later, after go-live... a new, unrelated major feature D is added. Instead of creating a new backend server or class to implement D, it is shoe-horned into the existing A/B/C backend server or classes or whatever. And then feature, E, feature F, etc... all shoehorned into whatever the original architecture / components were, instead of adding dedicated new components for D and E and F, just like happened for A/B/C.<p>Obviously, over time, this just leads to a big mess. Not only do you not end up with a dedicated, self-contained implementation for D, you also destroy the dedicated, self-contained components you originally had for A/B/C in the process, and after a bit of time it turns into a big unstructured mess.<p>I always find this kind of bizarre, because often the original structure is pretty sensible, and all that's required is to continue applying the same reasoning and techniques to new features as was applied to the original ones.<p>Sometimes there are administrative disincentives that encourage this, like requiring some onerous approval for a &quot;new&quot; server / class / source file, but a lightweight process for a &quot;change&quot; to an existing thing... but for the most part it just seems to be odd that people can't apply more of what's already in front of them, instead of destroying it.",
  "keywords": [
    "Ask HN"
  ],
  "genre": "Ask HN",
  "author": {
    "@type": "Person",
    "name": "tacostakohashi",
    "url": "https://news.ycombinator.com/user?id=tacostakohashi"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=32193017",
  "sameAs": "https://news.ycombinator.com/item?id=32193017",
  "dateCreated": "2022-07-22T15:30:25.247Z",
  "datePublished": "2022-07-22T15:28:16.000Z",
  "dateModified": "2022-07-22T15:30:25.247Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 1
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 0
    }
  ],
  "headline_zh-Hans": "Ask HN: 对这种特殊的熵/技术债务有什么名称/隐喻吗？\n",
  "headline_zh-Hant": "Ask HN: 對這種特殊的熵/技術債務有什麼名稱/隱喻嗎？\n",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "我在许多组织中反复看到的一件事是，一个新产品从头开始设计和实施，使用一个相当合理的逻辑结构/架构。<p>例如，也许有一个前端连接到三个独立的后台服务器，A、B和C，它们都处理一些不同的、自足的逻辑事物。或者，也许事情被划分为关键类A、B和C，每个关键类都封装了一个自足的功能。如果B崩溃了，你就知道它是由于某个特定功能的问题造成的。这一切都很合理，也很容易推理。<p>后来，在上线之后......一个新的、不相关的主要功能D被添加进来。我们没有创建一个新的后台服务器或类来实现D，而是把它塞进了现有的A/B/C后台服务器或类或其他东西中。然后功能E、功能F等等......都被塞进了原来的架构/组件中，而不是像A/B/C那样为D、E和F添加专门的新组件。<p>显然，随着时间的推移，这只会导致一个大混乱。<p>你不仅最终没有为D提供一个专门的、独立的实现，你还在这个过程中破坏了你最初为A/B/C提供的专门的、独立的组件，并且在一段时间后，它变成了一个大的非结构化的混乱。<p>我总是觉得这种情况很奇怪，因为通常原始结构是非常合理的，所需要的只是继续将同样的推理和技术应用于新的功能，就像应用于原始功能一样。 <p>有时会有一些行政上的抑制措施来鼓励这种做法，比如对于一个&quot;新&quot;服务器/类/源文件需要一些繁琐的批准，但对于一个现有的东西的&quot;改变&quot;却需要一个轻量级的过程......但在大多数情况下，人们不能更多地应用已经在他们面前的东西而不是破坏它，这似乎很奇怪。\n",
  "description_zh-Hant": "我在許多組織中反覆看到的一件事是，一個新產品從頭開始設計和實施，使用一個相當合理的邏輯結構/架構。<p>例如，也許有一個前端連接到三個獨立的後臺服務器，A、B和C，它們都處理一些不同的、自足的邏輯事物。或者，也許事情被劃分為關鍵類A、B和C，每個關鍵類都封裝了一個自足的功能。如果B崩潰了，你就知道它是由於某個特定功能的問題造成的。這一切都很合理，也很容易推理。<p>後來，在上線之後......一個新的、不相關的主要功能D被添加進來。我們沒有創建一個新的後臺服務器或類來實現D，而是把它塞進了現有的A/B/C後臺服務器或類或其他東西中。然後功能E、功能F等等......都被塞進了原來的架構/組件中，而不是像A/B/C那樣為D、E和F添加專門的新組件。<p>顯然，隨著時間的推移，這隻會導致一個大混亂。<p>你不僅最終沒有為D提供一個專門的、獨立的實現，你還在這個過程中破壞了你最初為A/B/C提供的專門的、獨立的組件，並且在一段時間後，它變成了一個大的非結構化的混亂。<p>我總是覺得這種情況很奇怪，因為通常原始結構是非常合理的，所需要的只是繼續將同樣的推理和技術應用於新的功能，就像應用於原始功能一樣。 <p>有時會有一些行政上的抑制措施來鼓勵這種做法，比如對於一個&quot;新&quot;服務器/類/源文件需要一些繁瑣的批准，但對於一個現有的東西的&quot;改變&quot;卻需要一個輕量級的過程......但在大多數情況下，人們不能更多地應用已經在他們面前的東西而不是破壞它，這似乎很奇怪。\n"
}