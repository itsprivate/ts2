{
  "@type": "NewsArticle",
  "identifier": "2022--07--16--en--askhn--HackerNews--NewsArticle--32118929",
  "url": "https://news.ycombinator.com/item?id=32118929",
  "headline": "Ask HN: Thoughts on C23 Stdckdint.h",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "I've just learned that the stdckdint.h [1] header is in the C2x standard. I'm not really a C programmer, so I can't help but ask myself how does the committee expect libc developers to implement those macros without generics, 128bit integers, or even statement expressions? Are they going to add generics in C2x?\nSo I figured out C veterans on HN would have some ideas on how they would implement this. Really all that I can think is generate functions for every possible type triplet using some preprocessor X_Macro magic (you guys still use the preprocessor, right?). I don't know, I'm kinda spoiled by Rust in this case.\n Hey, we could even help a libc developer with this thread!<p>[1]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2792.pdf",
  "keywords": [
    "Ask HN"
  ],
  "genre": "Ask HN",
  "author": {
    "@type": "Person",
    "name": "DiamontIsComing",
    "url": "https://news.ycombinator.com/user?id=DiamontIsComing"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=32118929",
  "sameAs": "https://news.ycombinator.com/item?id=32118929",
  "dateCreated": "2022-07-16T15:25:37.402Z",
  "datePublished": "2022-07-16T15:15:01.000Z",
  "dateModified": "2022-07-16T15:25:37.402Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 1
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 0
    }
  ],
  "headline_zh-Hans": "Ask HN: 关于C23 Stdckdint.h的思考\n",
  "headline_zh-Hant": "Ask HN: 關於C23 Stdckdint.h的思考\n",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "我刚刚知道stdckdint.h[1]头在C2x标准中。我并不是一个真正的C程序员，所以我不禁问自己，如果没有泛型、128位整数，甚至没有语句表达式，委员会如何期望libc开发者实现那些宏？他们会在C2x中增加泛型吗？\n所以我想HN上的C语言老手们会对他们如何实现这个问题有一些想法。实际上，我所能想到的就是使用一些预处理器X_Macro魔法为每一个可能的类型三联体生成函数（你们仍然使用预处理器，对吗？） 我不知道，在这种情况下，我有点被Rust宠坏了。\n 嘿，我们甚至可以用这个线程帮助一个libc开发者！<p>[1]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2792.pdf\n",
  "description_zh-Hant": "我剛剛知道stdckdint.h[1]頭在C2x標準中。我並不是一個真正的C程序員，所以我不禁問自己，如果沒有泛型、128位整數，甚至沒有語句表達式，委員會如何期望libc開發者實現那些宏？他們會在C2x中增加泛型嗎？\n所以我想HN上的C語言老手們會對他們如何實現這個問題有一些想法。實際上，我所能想到的就是使用一些預處理器X_Macro魔法為每一個可能的類型三聯體生成函數（你們仍然使用預處理器，對嗎？） 我不知道，在這種情況下，我有點被Rust寵壞了。\n 嘿，我們甚至可以用這個線程幫助一個libc開發者！<p>[1]: http://www.open-std.org/jtc1/sc22/wg14/www/docs/n2792.pdf\n"
}