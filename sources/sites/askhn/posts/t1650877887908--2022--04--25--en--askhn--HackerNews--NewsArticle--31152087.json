{
  "@type": "NewsArticle",
  "identifier": "2022--04--25--en--askhn--HackerNews--NewsArticle--31152087",
  "url": "https://news.ycombinator.com/item?id=31152087",
  "headline": "Ask HN: What languages have true native cooperative multitasking?",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "and also, &quot;how well did it work?&quot;<p>But let me clarify exactly what I'm asking here, because concepts like &quot;coroutines&quot; or &quot;cooperative multitasking&quot; or &quot;multiprocessing&quot; get heavily influenced by their implementation in each language, and I'm asking for a very specific implementation.<p>In a stack-based function-call language, there is usually a simple API of blocking I/O where the state of each in-progress function is preserved on a stack as the entire thread of execution is paused until the completion of the I/O.  This leads to very clear and easy-to-debug programs, usually with the added convenience of throwing and catching exceptions, but you can only process one I/O sequence (client/server conversation, etc) per thread.  Moving to multiple threads or parallel processes lead to complex concurrency problems, and often don't scale well.<p>Languages usually also provide more complex secondary APIs for non-blocking I/O that allows a function to start an I/O operation and continue doing other things while checking the status of the I/O, or blocking on an event API to wake up when something is ready.  Taken to its logical conclusion, the program becomes structured around an event loop, but the programmer must now track the on-going state of a particular I/O sequence in their own data structures without the convenience of a stack-based tree of function calls.  You can no longer use normal language exceptions to abort a single I/O conversation because it is interleaved with other conversations and the logical call-tree is gone.  The program must also avoid using any library which makes use of blocking APIs, dividing the library ecosystem into &quot;blocking&quot; and &quot;nonblocking-compatible&quot; halves.<p>One solution is to add co-routines to a language, where multiple function-call tree stacks are held in memory, and executed on a single thread.  Any time a blocking API is used, the language starts the I/O operation then switches to another co-routine that is ready to run.  In other words, the language manages the event loop hidden in the background while presenting the user with what appears to be normal threads, but without most of the hard synchronization that you need from true multithreading.  The downsides are that a function with a long-running calculation not involving I/O will delay the processing of the I/O of all other co-routines, and there might still be synchronization issues if I/O operations are interleaved with changes to data structures.<p>Most scripting languages provide <i>something</i> for co-routines, but usually requiring some invasive changes to the code that are not just the simple blocking APIs presented by the stock language.<p>Python: the generators act like independent call stacks, and were made into &quot;co-routines&quot; with a send() call, but these do not tie into the native blocking API read/write/sleep to perform event-driven I/O like I described above.  The co-routines are also used like objects instead of called like normal functions.<p>JavaScript: JS has the Async/Await system which is almost what I describe, but they are exposed as keywords which must be used in the code, not passively compatible with other code using blocking I/O.<p>Perl: there is a Coro library that switches the interpreter stacks, but does not intercept the blocking I/O.  There are several &quot;AsyncAwait&quot; modules, with the same caveat as JS.<p>There are so many languages out there, I'm sure that someone has already implemented intrinsic co-routines + non-blocking I/O exposed to the user as a simple blocking cooperative threads.  I want to know which languages have tried this, and maybe more importantly, if you have worked on a project that used them, how well the idea works in practice.",
  "keywords": [
    "Ask HN"
  ],
  "genre": "Ask HN",
  "author": {
    "@type": "Person",
    "name": "nrdvana",
    "url": "https://news.ycombinator.com/user?id=nrdvana"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=31152087",
  "sameAs": "https://news.ycombinator.com/item?id=31152087",
  "dateCreated": "2022-04-25T09:11:27.908Z",
  "datePublished": "2022-04-25T09:07:45.000Z",
  "dateModified": "2022-04-25T09:11:27.908Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 1
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 0
    }
  ],
  "headline_zh-Hans": "Ask HN: 哪些语言有真正的本地合作多任务？",
  "headline_zh-Hant": "Ask HN: 哪些語言有真正的本地合作多任務？",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "还有，&quot;效果如何？&quot;<p>但让我澄清一下我到底在问什么，因为像&quot;coroutines&quot;或&quot;cooperative multitasking&quot;或&quot;multiprocessing&quot;这样的概念会受到它们在每种语言中实现的严重影响，而我问的是非常具体的实现。 <p>在基于堆栈的函数调用语言中，通常有一个简单的阻塞式I/O的API，其中每个进行中的函数的状态被保存在堆栈中，因为整个执行线程被暂停，直到I/O的完成。 这导致了非常清晰和容易调试的程序，通常还有抛出和捕获异常的便利性，但每个线程只能处理一个I/O序列（客户/服务器对话等）。 转向多线程或并行进程会导致复杂的并发问题，而且往往不能很好地扩展。<p>语言通常还为非阻塞I/O提供更复杂的二级API，允许一个函数开始I/O操作，并在检查I/O状态的同时继续做其他事情，或者在事件API上阻塞，以便在事情准备好时唤醒。 从逻辑上看，程序变成了围绕事件循环的结构，但程序员现在必须在他们自己的数据结构中跟踪特定I/O序列的持续状态，而没有基于堆栈的函数调用树的便利。 你不能再使用普通语言的异常来中止一个单一的I/O对话，因为它与其他对话交错在一起，逻辑调用树已经消失。 程序还必须避免使用任何利用阻塞API的库，将库的生态系统分为&quot;阻塞&quot;和&quot;非阻塞兼容&quot;两半。<p>一种解决方案是在语言中添加联合程序，将多个函数调用树堆栈保存在内存中，并在单个线程上执行。 任何时候，只要使用阻塞式API，语言就会启动I/O操作，然后切换到另一个准备运行的联合程序。 In other words, the language manages the event loop hidden in the background while presenting the user with what appears to be normal threads, but without most of the hard synchronization that you need from true multithreading.  The downsides are that a function with a long-running calculation not involving I/O will delay the processing of the I/O of all other co-routines, and there might still be synchronization issues if I/O operations are interleaved with changes to data structures. <p>大多数脚本语言都为联合程序提供了<i>某种东西</i>，但通常需要对代码进行一些侵入性的修改，而不仅仅是原生语言所提供的简单阻塞API。<p>Python：生成器就像独立的调用栈，并被做成&quot;联合程序&quot;，带有send()调用，但这些并没有与原生阻塞API read/write/sleep绑定，以执行像我上面描述的事件驱动的I/O。 这些联合程序也像对象一样被使用，而不是像普通函数一样被调用。JS有Async/Await系统，这几乎是我所描述的，但它们作为关键字暴露出来，必须在代码中使用，而不是被动地与其他使用阻塞式I/O的代码兼容。<p>Perl：有一个Coro库可以切换解释器堆栈，但不拦截阻塞式I/O。 有几个&quot;AsyncAwait&quot;模块，其注意事项与JS相同。<p>有这么多语言，我相信已经有人实现了内在的协同程序+非阻塞I/O，作为一个简单的阻塞合作线程暴露给用户。 我想知道哪些语言已经尝试过这种做法，也许更重要的是，如果你曾在一个项目中使用过它们，那么这个想法在实践中的效果如何。",
  "description_zh-Hant": "還有，&quot;效果如何？&quot;<p>但讓我澄清一下我到底在問什麼，因為像&quot;coroutines&quot;或&quot;cooperative multitasking&quot;或&quot;multiprocessing&quot;這樣的概念會受到它們在每種語言中實現的嚴重影響，而我問的是非常具體的實現。 <p>在基於堆棧的函數調用語言中，通常有一個簡單的阻塞式I/O的API，其中每個進行中的函數的狀態被保存在堆棧中，因為整個執行線程被暫停，直到I/O的完成。 這導致了非常清晰和容易調試的程序，通常還有拋出和捕獲異常的便利性，但每個線程只能處理一個I/O序列（客戶/服務器對話等）。 轉向多線程或並行進程會導致複雜的併發問題，而且往往不能很好地擴展。<p>語言通常還為非阻塞I/O提供更復雜的二級API，允許一個函數開始I/O操作，並在檢查I/O狀態的同時繼續做其他事情，或者在事件API上阻塞，以便在事情準備好時喚醒。 從邏輯上看，程序變成了圍繞事件循環的結構，但程序員現在必須在他們自己的數據結構中跟蹤特定I/O序列的持續狀態，而沒有基於堆棧的函數調用樹的便利。 你不能再使用普通語言的異常來中止一個單一的I/O對話，因為它與其他對話交錯在一起，邏輯調用樹已經消失。 程序還必須避免使用任何利用阻塞API的庫，將庫的生態系統分為&quot;阻塞&quot;和&quot;非阻塞兼容&quot;兩半。<p>一種解決方案是在語言中添加聯合程序，將多個函數調用樹堆棧保存在內存中，並在單個線程上執行。 任何時候，只要使用阻塞式API，語言就會啟動I/O操作，然後切換到另一個準備運行的聯合程序。 In other words, the language manages the event loop hidden in the background while presenting the user with what appears to be normal threads, but without most of the hard synchronization that you need from true multithreading.  The downsides are that a function with a long-running calculation not involving I/O will delay the processing of the I/O of all other co-routines, and there might still be synchronization issues if I/O operations are interleaved with changes to data structures. <p>大多數腳本語言都為聯合程序提供了<i>某種東西</i>，但通常需要對代碼進行一些侵入性的修改，而不僅僅是原生語言所提供的簡單阻塞API。<p>Python：生成器就像獨立的調用棧，並被做成&quot;聯合程序&quot;，帶有send()調用，但這些並沒有與原生阻塞API read/write/sleep綁定，以執行像我上面描述的事件驅動的I/O。 這些聯合程序也像對象一樣被使用，而不是像普通函數一樣被調用。JS有Async/Await系統，這幾乎是我所描述的，但它們作為關鍵字暴露出來，必須在代碼中使用，而不是被動地與其他使用阻塞式I/O的代碼兼容。<p>Perl：有一個Coro庫可以切換解釋器堆棧，但不攔截阻塞式I/O。 有幾個&quot;AsyncAwait&quot;模塊，其注意事項與JS相同。<p>有這麼多語言，我相信已經有人實現了內在的協同程序+非阻塞I/O，作為一個簡單的阻塞合作線程暴露給用戶。 我想知道哪些語言已經嘗試過這種做法，也許更重要的是，如果你曾在一個項目中使用過它們，那麼這個想法在實踐中的效果如何。"
}