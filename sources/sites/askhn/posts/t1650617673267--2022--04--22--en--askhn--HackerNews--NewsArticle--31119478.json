{
  "@type": "NewsArticle",
  "identifier": "2022--04--22--en--askhn--HackerNews--NewsArticle--31119478",
  "url": "https://news.ycombinator.com/item?id=31119478",
  "headline": "Ask HN: How do I handle Unicode passwords?",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "Hello, I was recently asked to, if possible, implement Unicode in the password field. The storage is not itself a problem - the hasher itself can accept binary, so I could use UTF-8 so that I wouldn't need to migrate ASCII passwords. My question is before that hasher: I'm aware that Unicode in itself is so messy that you need to normalise it first into <i>something</i> (https://en.wikipedia.org/wiki/Unicode_equivalence) so that would not run on normalisation bugs (such as https://eclecticlight.co/2021/05/08/explainer-unicode-normalization-and-apfs/). If it's impossible, I would have to write a detailed reason since the application is used around the world and they would really prefer to support Unicode passwords.",
  "keywords": [
    "Ask HN"
  ],
  "genre": "Ask HN",
  "author": {
    "@type": "Person",
    "name": "unipassword",
    "url": "https://news.ycombinator.com/user?id=unipassword"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=31119478",
  "sameAs": "https://news.ycombinator.com/item?id=31119478",
  "dateCreated": "2022-04-22T08:54:33.267Z",
  "datePublished": "2022-04-22T08:44:10.000Z",
  "dateModified": "2022-04-22T08:54:33.267Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 1
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 0
    }
  ],
  "headline_zh-Hans": "Ask HN: 如何处理Unicode密码？",
  "headline_zh-Hant": "Ask HN: 如何處理Unicode密碼？",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "你好，我最近被要求，如果可能的话，在密码领域实现Unicode。存储本身不是问题--hasher本身可以接受二进制，所以我可以使用UTF-8，这样我就不需要迁移ASCII密码了。我的问题是在那个hasher之前。我知道Unicode本身很乱，你需要先把它规范化为<i>something</i>（https://en.wikipedia.org/wiki/Unicode_equivalence），这样就不会在规范化的bug上运行（比如https://eclecticlight.co/2021/05/08/explainer-unicode-normalization-and-apfs/）。如果这是不可能的，我将不得不写一个详细的理由，因为这个应用程序是在世界各地使用的，他们真的希望支持Unicode密码。",
  "description_zh-Hant": "你好，我最近被要求，如果可能的話，在密碼領域實現Unicode。存儲本身不是問題--hasher本身可以接受二進制，所以我可以使用UTF-8，這樣我就不需要遷移ASCII密碼了。我的問題是在那個hasher之前。我知道Unicode本身很亂，你需要先把它規範化為<i>something</i>（https://en.wikipedia.org/wiki/Unicode_equivalence），這樣就不會在規範化的bug上運行（比如https://eclecticlight.co/2021/05/08/explainer-unicode-normalization-and-apfs/）。如果這是不可能的，我將不得不寫一個詳細的理由，因為這個應用程序是在世界各地使用的，他們真的希望支持Unicode密碼。"
}