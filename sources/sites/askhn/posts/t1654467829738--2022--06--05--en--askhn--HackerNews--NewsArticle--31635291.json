{
  "@type": "NewsArticle",
  "identifier": "2022--06--05--en--askhn--HackerNews--NewsArticle--31635291",
  "url": "https://news.ycombinator.com/item?id=31635291",
  "headline": "Ask HN: Order preserving hashes for learned Indexes",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "https://github.com/rodgarrison/PGM-index was previously posted to HN. However, to leverage PGM for keys that are strings or blobs (arrays of unsigned bytes) one needs a map from the key as an array of bytes to some integral type. What are the options here?<p>An order preserving hash is such that if keys k0&lt;=k1 then hash(k0)&lt;=hash(k1).<p>As far as I can tell the broad outline of options include:<p>* naive options like put all strings in a std map and give the index to the entry as the hash value<p>* Some variation of converting the key into a bitstream, maybe with compression hoping to get into a 64-256 bit range.<p>* Putting the keys into a trie or BST and converting the path through the structure to the key into a bitstream which becomes an int.<p>* An actual order preserving hash e.g. something like this: https://github.com/DominikHorn/exotic-hashing/tree/main/include/omphf<p>Does anybody know better? An important property (and relaxation) is that all the strings need may not be known ahead of time. So the hash need not be minimal.",
  "keywords": [
    "Ask HN"
  ],
  "genre": "Ask HN",
  "author": {
    "@type": "Person",
    "name": "scrubs",
    "url": "https://news.ycombinator.com/user?id=scrubs"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=31635291",
  "sameAs": "https://news.ycombinator.com/item?id=31635291",
  "dateCreated": "2022-06-05T22:23:49.738Z",
  "datePublished": "2022-06-05T22:11:02.000Z",
  "dateModified": "2022-06-05T22:23:49.738Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 1
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 0
    }
  ],
  "headline_zh-Hans": "Ask HN: 为学习型索引保留顺序的哈希值\n",
  "headline_zh-Hant": "Ask HN: 為學習型索引保留順序的哈希值\n",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "https://github.com/rodgarrison/PGM-index 以前曾在HN上发布过。然而，为了利用PGM来处理字符串或Blobs（无符号字节数组）的键，我们需要一个从作为字节数组的键到一些积分类型的映射。<p>保序散列是这样的：如果键k0&lt;=k1，那么hash(k0)&lt;=hash(k1)。<p>就我所知，大致的选项包括：<p>* 天真的选项，如将所有字符串放在一个std map中，并将条目的索引作为散列值<p>* 将键转换为比特流的一些变化，也许通过压缩希望能进入64-256位范围。 <p>* 将键放入一个 trie 或 BST 中，并将通过该结构到达键的路径转换为比特流，成为一个 int。<p>* 一个实际的保存顺序的哈希值，例如像这样：https://github.com/DominikHorn/exotic-hashing/tree/main/include/omphf<p>有没有人知道更好的？一个重要的属性（和放松）是，所有需要的字符串可能不会提前知道。所以哈希值不一定是最小的。\n",
  "description_zh-Hant": "https://github.com/rodgarrison/PGM-index 以前曾在HN上發佈過。然而，為了利用PGM來處理字符串或Blobs（無符號字節數組）的鍵，我們需要一個從作為字節數組的鍵到一些積分類型的映射。<p>保序散列是這樣的：如果鍵k0&lt;=k1，那麼hash(k0)&lt;=hash(k1)。<p>就我所知，大致的選項包括：<p>* 天真的選項，如將所有字符串放在一個std map中，並將條目的索引作為散列值<p>* 將鍵轉換為比特流的一些變化，也許通過壓縮希望能進入64-256位範圍。 <p>* 將鍵放入一個 trie 或 BST 中，並將通過該結構到達鍵的路徑轉換為比特流，成為一個 int。<p>* 一個實際的保存順序的哈希值，例如像這樣：https://github.com/DominikHorn/exotic-hashing/tree/main/include/omphf<p>有沒有人知道更好的？一個重要的屬性（和放鬆）是，所有需要的字符串可能不會提前知道。所以哈希值不一定是最小的。\n"
}