{
  "@type": "NewsArticle",
  "identifier": "2022--03--17--en--hackernews--HackerNews--NewsArticle--30712175",
  "url": "https://news.ycombinator.com/item?id=30712175",
  "headline": "Ask HN: What is your Git commit/push flow?",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "I've long been in the practice of &quot;commit early, commit often&quot;.  If one use case works I commit, if the unit tests pass I commit. The code may be a mess, the variables may have names like 'foo' and 'bar' but I commit to have a last known good state.  If I start mass refactoring and break the unit tests, I can revert everything and start over.<p>I also push often because I'm forever aware disks can fail.  I'm not leaving a day's worth of work on my local drive and hoping it's there the next morning.<p>I've become increasingly aware that my coworkers have nice clean commit histories.  When I look at their PRs, there are 2-4 commits and each is a clean, completely functioning feature.  No &quot;fix misspellings and whitespace&quot; comments.<p>What flow do you follow?",
  "keywords": [
    "Ask HN"
  ],
  "genre": "Ask HN",
  "author": {
    "@type": "Person",
    "name": "nineplay",
    "url": "https://news.ycombinator.com/user?id=nineplay"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=30712175",
  "sameAs": "https://news.ycombinator.com/item?id=30712175",
  "dateCreated": "2022-03-17T15:40:03.763Z",
  "datePublished": "2022-03-17T15:27:51.000Z",
  "dateModified": "2022-03-17T15:40:03.763Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 11
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 6
    }
  ],
  "headline_zh-Hans": "Ask HN: 你的Git提交/推送流程是什么？",
  "headline_zh-Hant": "Ask HN: 你的Git提交/推送流程是什麼？",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "长期以来，我一直奉行 \"尽早提交，经常提交 \"的原则。 如果一个用例成功，我就提交，如果单元测试通过，我就提交。代码可能是一团糟，变量可能有 \"foo \"和 \"bar \"这样的名字，但我提交的目的是为了获得最后的良好状态。 如果我开始大规模重构并破坏了单元测试，我可以恢复一切并重新开始。<p>我也经常推送，因为我永远知道磁盘可能会失败。 我不会把一天的工作留在本地硬盘上，希望第二天早上还在那里。<p>我越来越意识到，我的同事们有很好的干净的提交历史记录。 当我看他们的PR时，有2-4个提交，每个都是一个干净的、完全正常的特性。 没有&quot;修复拼写错误和空白&quot;的评论。<p>你遵循什么流程？",
  "description_zh-Hant": "長期以來，我一直奉行 \"儘早提交，經常提交 \"的原則。 如果一個用例成功，我就提交，如果單元測試通過，我就提交。代碼可能是一團糟，變量可能有 \"foo \"和 \"bar \"這樣的名字，但我提交的目的是為了獲得最後的良好狀態。 如果我開始大規模重構並破壞了單元測試，我可以恢復一切並重新開始。<p>我也經常推送，因為我永遠知道磁盤可能會失敗。 我不會把一天的工作留在本地硬盤上，希望第二天早上還在那裡。<p>我越來越意識到，我的同事們有很好的乾淨的提交歷史記錄。 當我看他們的PR時，有2-4個提交，每個都是一個乾淨的、完全正常的特性。 沒有&quot;修復拼寫錯誤和空白&quot;的評論。<p>你遵循什麼流程？"
}