{
  "@type": "NewsArticle",
  "identifier": "2022--08--09--en--hackernews--HackerNews--NewsArticle--32400849",
  "url": "https://news.ycombinator.com/item?id=32400849",
  "headline": "Launch HN: Windmill (YC S22) – Turn scripts into internal apps and workflows",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "Ruben Fiszel here, software engineer, long-time lurker of Hacker News and founder of Windmill. Windmill is a fully open-source self-hostable platform and runtime to build complex workflows, internal apps and integrations using any scripts in Python or Typescript-deno. I am back after having been revealed a bit too soon on HN and miraculously getting into YC (<a href=\"https://news.ycombinator.com/item?id=31272793\" rel=\"nofollow\">https://news.ycombinator.com/item?id=31272793</a>).<p>To build internal apps for ops, integrations between services that cannot talk to each other directly, or to run background jobs that run your business logic and analytics, the two main options today are no-code solutions and old-fashioned, roll-your-own scripting. Both have problems, and our goal with Windmill is to find a new sweet spot between the two. No-code solutions are productive <i>if</i> your problem matches the tool exactly - but it not, they are rigid, hard to extend and quickly become tech debt, annihilating their initial time advantage. Indeed, no-code is just code but made by an opinionated someone else and hidden as a blackbox with an UI.<p>The alternative is to do it the old-fashioned way, writing everything from scratch, both backend and frontend, perhaps deploying it on the latest flavor of serverless, and pray to never have to touch it again because that took way too much time and it has now became a burden that the ops and business team might poke you about regularly.<p>Furthermore, the landscape of SaaS is specialized tools for everything—alerting, data analytics, administration panels, support management, integration between services—when it feels like a few scripts would have been as good or even better and spared you the need of depending on one yet another tool. This could be even further facilitated if there was a way to import the right bunch of scripts from a fellow community of engineers, tweak it and deploy it like you can do in communities where automation can be shared as simple JSON files, for instance in the node-red or home assistant community.. That’s the idea of Windmill: to bring back the power of scripting in an easy way.<p>With Windmill, you write normal scripts, or reuse ones made by others, and we make them production-grade and composable. You shouldn’t have to worry about things like http requests or scheduling jobs. We abstract much of that away, making your scripts be both more focused and more composable. You end up doing things the right way but much quicker.<p>We reduce the complexity of workflows, integrations and internal apps by uniting them all under one banner. At the heart, they mostly have the same needs: workflows with a UI or a schedule. One tool that does it all out-of-the-box offers greater consistency and allows you to grow the complexity of your toolset at your own pace.<p>I have an academic background in compilers and industry experience in distributed systems. My compiler work made me wary of solving every problem with a domain-specific-language (DSL) or complex frameworks. We can just do more with the well-crafted existing languages like Python or Typescript.  Rolling up your own DSL is nice in theory, you can make it very ergonomic and focused on the task at hand, but then you start adding features and either reinvent existing – albeit worse – programming language or decide to stop there. In the very large majority of cases, a well crafted library is vastly superior to any DSL. By being able to use any library of Python and Typescript, we stand on the shoulders of giants.<p>I have also observed that the best distributed systems are often the most simple as they are more predictable and have invariants that are easier to reason with and scale horizontally. This is why for Windmill, we rely solely on Postgres + our native workers + our http REST api layer. Later on, we plan to build adapters to host the workers on AWS lambda or Cloudflare workers, and the queue on Kafka if your needs are exceptionally high.<p>At the heart of what we have built is a queue implemented in Postgres and workers implemented in Rust that create a sandbox (using nsjail), fetch dependencies, and execute  scripts. Every script can be triggered through its name  with an HTTP POST by passing a JSON payload in which every field corresponds 1:1 to an argument of the script’s main parameter. Most primitive types in Python or Typescript have a natural corresponding type in JSON so the conversion is always what you would expect.  We then execute the script inside a new sandbox and then store the results in the same Postgres DB at the end of the job execution.<p>The HTTP payload can be sent from your own frontend or you can use our automatically generated UI. Indeed, we do a simple, yet effective analysis of the parameters of your script, and from it, generate the jsonschema corresponding to your parameters. That schema is what enables us to convert any script into a no-code like module for flow or a standalone internal app with its auto-generated UI. In the case of Python, we also look at the imports to deduce the Pypi dependencies without you having to declare them.<p>For flows, we defined an open spec for building them out of those scripts we call OpenFlow: <a href=\"https://docs.windmill.dev/docs/openflow\" rel=\"nofollow\">https://docs.windmill.dev/docs/openflow</a>. It  is essentially a json format for describing a sequence of steps with for loops and soon branching. The most interesting bit here is that each input of each step can define its input as a javascript expression that refers to and transforms the output of any previous step. We make it fast by leveraging native v8 integration in Rust (thanks to the deno team) for executing those expressions. This makes this apparently linear sequence a flexible DAG in which one can express complex workflows.<p>Then on top of that we have an UI builder for flows that hides most of the complexity to give an experience that is similar to a low-code platform where every step is treated as a blackbox. The platform itself offers all the features that you would expect: a variable and object store for storing states, plain values and credentials; a cron scheduler for flows and scripts, tight permissioning for the sensitive credentials and variables, groups, a webeditor with smart assistant to edit the scripts directly in the platform etc. Finally, we made a hub (<a href=\"https://hub.windmill.dev\" rel=\"nofollow\">https://hub.windmill.dev</a>) to share flows and scripts with everyone. The goal is to grow over time an exhaustive library of pre-made modules and flows to tweak from so that you can focus on what is actually custom to you.<p>Windmill is open-source and self-hostable. You can think of it as a superset of both Pipedream and Airplane.dev. Compared to Temporal, the scripts themselves are agnostic of the flow in which they are embedded, which has the benefit of making it easier to build a hub of reusable modules. We are the only ones as far as we know to convert script parameters to UI automatically. We see ourselves as complementary to UI builder solutions like Retool or Tooljet as we do not want to focus too much on the auto-generated UI and could be used solely as the backend part of the two aforementioned tools.<p>We are now a team of 3 senior engineers and the product is progressing faster than ever with a public roadmap: <a href=\"https://github.com/orgs/windmill-labs/projects/2\" rel=\"nofollow\">https://github.com/orgs/windmill-labs/projects/2</a><p>We make money from commercial licenses, support and plugins for enterprise and team plans on the hosted solution.<p>You can self-host it or try it  <a href=\"https://app.windmill.dev\" rel=\"nofollow\">https://app.windmill.dev</a>, the free tier is generous (and the paid one is not enforced yet). Our landing page is: <a href=\"https://windmill.dev\" rel=\"nofollow\">https://windmill.dev</a>. We would appreciate your feedback and ideas and look forward to all your comments!",
  "keywords": [],
  "author": {
    "@type": "Person",
    "name": "rubenfiszel",
    "url": "https://news.ycombinator.com/user?id=rubenfiszel"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=32400849",
  "sameAs": "https://news.ycombinator.com/item?id=32400849",
  "dateCreated": "2022-08-09T17:37:16.970Z",
  "datePublished": "2022-08-09T17:19:18.000Z",
  "dateModified": "2022-08-09T17:37:16.970Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 24
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 1
    }
  ],
  "headline_zh-Hans": "启动HN：大风车（YC S22）--将脚本变成内部应用程序和工作流程\n",
  "headline_zh-Hant": "啟動HN：大風車（YC S22）--將腳本變成內部應用程序和工作流程\n",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "Ruben Fiszel here, software engineer, long-time lurker of Hacker News and founder of Windmill. Windmill is a fully open-source self-hostable platform and runtime to build complex workflows, internal apps and integrations using any scripts in Python or Typescript-deno. I am back after having been revealed a bit too soon on HN and miraculously getting into YC (<a href=\"https://news.ycombinator.com/item?id=31272793\" rel=\"nofollow\">https://news.ycombinator.com/item?id=31272793</a>).<p>To build internal apps for ops, integrations between services that cannot talk to each other directly, or to run background jobs that run your business logic and analytics, the two main options today are no-code solutions and old-fashioned, roll-your-own scripting. Both have problems, and our goal with Windmill is to find a new sweet spot between the two. No-code solutions are productive <i>if</i> your problem matches the tool exactly - but it not, they are rigid, hard to extend and quickly become tech debt, annihilating their initial time advantage. Indeed, no-code is just code but made by an opinionated someone else and hidden as a blackbox with an UI.<p>The alternative is to do it the old-fashioned way, writing everything from scratch, both backend and frontend, perhaps deploying it on the latest flavor of serverless, and pray to never have to touch it again because that took way too much time and it has now became a burden that the ops and business team might poke you about regularly. <p>Furthermore, the landscape of SaaS is specialized tools for everything—alerting, data analytics, administration panels, support management, integration between services—when it feels like a few scripts would have been as good or even better and spared you the need of depending on one yet another tool. 如果有一种方法可以从工程师社区导入合适的脚本，调整并部署它，就像你可以在社区中做的那样，自动化可以作为简单的JSON文件共享，例如在node-red或家庭助手社区中，这甚至可以进一步促进。这就是Windmill的想法：以一种简单的方式带回脚本的力量。<p>通过Windmill，你可以编写普通的脚本，或者重复使用别人制作的脚本，我们让它们成为生产级的、可组合的。你不应该担心http请求或工作调度等问题。我们把这些东西抽象出来，使你的脚本更有针对性，也更容易组合。<p>我们通过将工作流程、集成和内部应用程序统一到一个旗帜下，降低了它们的复杂性。在核心方面，它们大多有相同的需求：带有用户界面或时间表的工作流程。一个开箱即用的工具可以提供更大的一致性，并允许你按照自己的节奏增加工具集的复杂性。我的编译器工作使我对用特定领域语言（DSL）或复杂的框架来解决每一个问题持谨慎态度。我们可以用Python或Typescript等精心设计的现有语言做得更多。 从理论上讲，建立你自己的DSL是很好的，你可以使它非常符合人体工程学并专注于手头的任务，但随后你开始增加功能，要么重新发明现有的--尽管更糟糕的--编程语言，要么决定停止。在绝大多数情况下，一个精心设计的库要远远优于任何DSL。通过使用Python和Typescript的任何库，我们站在了巨人的肩膀上。<p>我还观察到，最好的分布式系统往往是最简单的，因为它们更容易预测，并且具有不变性，更容易推理和横向扩展。这就是为什么对于Windmill来说，我们只依赖于Postgres+我们的本地工人+我们的http REST api层。<p>我们所构建的核心是一个用Postgres实现的队列和用Rust实现的工作者，它们创建一个沙盒（使用nsjail），获取依赖，并执行脚本。每个脚本都可以通过HTTP POST的名称来触发，通过传递一个JSON有效载荷，其中每个字段都与脚本的主要参数1:1对应。Python或Typescript中的大多数原始类型在JSON中都有一个自然的对应类型，所以转换总是这样的\n",
  "description_zh-Hant": "Ruben Fiszel here, software engineer, long-time lurker of Hacker News and founder of Windmill. Windmill is a fully open-source self-hostable platform and runtime to build complex workflows, internal apps and integrations using any scripts in Python or Typescript-deno. I am back after having been revealed a bit too soon on HN and miraculously getting into YC (<a href=\"https://news.ycombinator.com/item?id=31272793\" rel=\"nofollow\">https://news.ycombinator.com/item?id=31272793</a>).<p>To build internal apps for ops, integrations between services that cannot talk to each other directly, or to run background jobs that run your business logic and analytics, the two main options today are no-code solutions and old-fashioned, roll-your-own scripting. Both have problems, and our goal with Windmill is to find a new sweet spot between the two. No-code solutions are productive <i>if</i> your problem matches the tool exactly - but it not, they are rigid, hard to extend and quickly become tech debt, annihilating their initial time advantage. Indeed, no-code is just code but made by an opinionated someone else and hidden as a blackbox with an UI.<p>The alternative is to do it the old-fashioned way, writing everything from scratch, both backend and frontend, perhaps deploying it on the latest flavor of serverless, and pray to never have to touch it again because that took way too much time and it has now became a burden that the ops and business team might poke you about regularly. <p>Furthermore, the landscape of SaaS is specialized tools for everything—alerting, data analytics, administration panels, support management, integration between services—when it feels like a few scripts would have been as good or even better and spared you the need of depending on one yet another tool. 如果有一種方法可以從工程師社區導入合適的腳本，調整並部署它，就像你可以在社區中做的那樣，自動化可以作為簡單的JSON文件共享，例如在node-red或家庭助手社區中，這甚至可以進一步促進。這就是Windmill的想法：以一種簡單的方式帶回腳本的力量。<p>通過Windmill，你可以編寫普通的腳本，或者重複使用別人製作的腳本，我們讓它們成為生產級的、可組合的。你不應該擔心http請求或工作調度等問題。我們把這些東西抽象出來，使你的腳本更有針對性，也更容易組合。<p>我們通過將工作流程、集成和內部應用程序統一到一個旗幟下，降低了它們的複雜性。在核心方面，它們大多有相同的需求：帶有用戶界面或時間表的工作流程。一個開箱即用的工具可以提供更大的一致性，並允許你按照自己的節奏增加工具集的複雜性。我的編譯器工作使我對用特定領域語言（DSL）或複雜的框架來解決每一個問題持謹慎態度。我們可以用Python或Typescript等精心設計的現有語言做得更多。 從理論上講，建立你自己的DSL是很好的，你可以使它非常符合人體工程學並專注於手頭的任務，但隨後你開始增加功能，要麼重新發明現有的--儘管更糟糕的--編程語言，要麼決定停止。在絕大多數情況下，一個精心設計的庫要遠遠優於任何DSL。通過使用Python和Typescript的任何庫，我們站在了巨人的肩膀上。<p>我還觀察到，最好的分佈式系統往往是最簡單的，因為它們更容易預測，並且具有不變性，更容易推理和橫向擴展。這就是為什麼對於Windmill來說，我們只依賴於Postgres+我們的本地工人+我們的http REST api層。<p>我們所構建的核心是一個用Postgres實現的隊列和用Rust實現的工作者，它們創建一個沙盒（使用nsjail），獲取依賴，並執行腳本。每個腳本都可以通過HTTP POST的名稱來觸發，通過傳遞一個JSON有效載荷，其中每個字段都與腳本的主要參數1:1對應。Python或Typescript中的大多數原始類型在JSON中都有一個自然的對應類型，所以轉換總是這樣的\n"
}