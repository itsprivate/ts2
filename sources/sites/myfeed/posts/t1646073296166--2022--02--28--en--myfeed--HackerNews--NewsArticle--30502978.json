{
  "@type": "NewsArticle",
  "identifier": "2022--02--28--en--myfeed--HackerNews--NewsArticle--30502978",
  "url": "https://news.ycombinator.com/item?id=30502978",
  "headline": "Launch HN: Drifting in Space (YC W22) – A server process for every user",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "Hi HN, we’re Paul and Taylor, and we’re launching Drifting in Space (<a href=\"https://driftingin.space\" rel=\"nofollow\">https://driftingin.space</a>). We build server software for performance-intensive browser-based applications. We make it easy to give every user of your app a dedicated server-side process, which starts when they open your application and stops when they close the tab.<p>Many high-end web apps give every user a dedicated connection to a server-side process. That is how they get the low latency that you need for ambitious products like full-fledged video editing tools and IDEs. This is hard for smaller teams to recreate, because it takes a significant ongoing engineering investment. That’s where we come in—we make this architecture available to everyone, so you can focus on your app instead of its infrastructure. You can think of it like Heroku, except that each of your users gets their own server instance.<p>I realized that something like this was needed while working on data-intensive tools at a hedge fund. I noticed that almost all new application software, whether it was built in-house or third-party SaaS, was delivered as a browser application rather than native. Although browsers are more powerful than ever, I knew from experience that industrial-scale data-heavy apps posed problems, because neither the browser or a traditional stateless server architecture could provide the compute resources needed for low-latency interaction with large datasets. I began talking about this with my friend Taylor, who had encountered similar limitations while working on data analysis and visualization tools at Datadog and Uber. We decided to team up and build a company around solving it.<p>We have two products, an open source package and a managed platform. Spawner, the open source part, provides an API for web apps to spawn a session-lived process. It manages the process’s lifecycle, exposing it over HTTPS, tracking inbound connections, and shutting it down when it becomes idle (i.e. when the user closes their tab). It’s open source (MIT) and available at <a href=\"https://github.com/drifting-in-space/spawner\" rel=\"nofollow\">https://github.com/drifting-in-space/spawner</a>.<p>Jamsocket is our managed platform, which uses Spawner internally. It provides the same API, but frees you from having to deal with any cluster or network configuration to ship code. From an app developer’s point of view, using it is similar to using platforms like Netlify or Render. You stay in the web stack and never have to touch Kubernetes.<p>Here's an example. Imagine you make an application for investigating fraud in a large transaction database. Users want to interactively filter, aggregate, and visualize gigabytes of transactions as a graph. Instead of sending all of the data down to the browser and doing the work there, you would put your code in a container and upload it to our platform. Then, whenever a fraud analyst opens your application, you hit an API we provide to spin up a dedicated backend for that analyst. Your browser code then opens a WebSocket connection directly to that backend, which it uses to stream data as the analyst applies filters or zooms/pans the visualization.<p>We're different from most managed platforms because we give each user a dedicated process. That said, there are a few other services that do run long-lived processes for each user. Architecturally, we're most similar to Agones. Agones is targeted at games where the client can speak UDP to an arbitrary IP; we target applications that want to connect directly from browsers to a hostname over HTTPS. In the Erlang world, the OTP stack provides similar functionality, but you have to embrace Erlang/Elixir to get the benefits of it; we are entirely language-agnostic. Cloudflare Durable Objects support a form of long-lived processes, but are focused on use cases around program state synchronization rather than arbitrary high-compute/memory use cases.<p>We have a usage-based billing model, similar to Heroku. We charge you for the compute you use and take a cut. Usage billing scales to zero, so it’s approachable for weekend experiments. We have not solidified a price plan yet, but we’re aiming to provide an instance capable of running VS Code (as an example) for about 10 cents an hour, fractionally metered. High-memory and high-CPU backends will cost more, and heavy users will get volume discounts. Our target customers are desktop-like SaaS apps and internal data tools.<p>As mentioned, our core API is open source and available at <a href=\"https://github.com/drifting-in-space/spawner\" rel=\"nofollow\">https://github.com/drifting-in-space/spawner</a>. The managed platform is in beta and we’re currently onboarding users from a waitlist, to make sure that we have the server capacity to scale. If you’re interested, you’re welcome to sign up for it here: <a href=\"https://driftingin.space\" rel=\"nofollow\">https://driftingin.space</a>.<p>Have you built a similar infrastructure for your application? We’re interested in hearing the approaches people have already taken to this problem and what the pain points are.",
  "keywords": [],
  "author": {
    "@type": "Person",
    "name": "paulgb",
    "url": "https://news.ycombinator.com/user?id=paulgb"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=30502978",
  "sameAs": "https://driftingin.space/",
  "dateCreated": "2022-02-28T18:34:56.166Z",
  "datePublished": "2022-02-28T18:10:42.000Z",
  "dateModified": "2022-02-28T18:34:56.166Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 9
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 0
    }
  ],
  "headline_zh-Hans": "启动HN：太空漂流（YC W22）--为每个用户提供一个服务器进程",
  "headline_zh-Hant": "啟動HN：太空漂流（YC W22）--為每個用戶提供一個服務器進程",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "嗨，HN，我们是Paul和Taylor，我们正在推出Drifting in Space（<a href=\"https://driftingin.space\" rel=\"nofollow\">https://driftingin.space</a>）。我们为基于浏览器的性能密集型应用构建服务器软件。我们可以轻松地为您的应用程序的每个用户提供一个专用的服务器端进程，该进程在用户打开您的应用程序时启动，并在用户关闭标签时停止。<p>许多高端 Web 应用程序为每个用户提供一个与服务器端进程的专用连接。这就是他们获得低延迟的方式，而你需要像成熟的视频编辑工具和 IDE 这样的雄心勃勃的产品。这对小型团队来说很难重现，因为这需要大量的持续工程投资。这就是我们的优势所在--我们向每个人提供这种架构，所以你可以专注于你的应用而不是它的基础设施。你可以把它想象成 Heroku，只不过你的每个用户都有自己的服务器实例。<p>我在一家对冲基金从事数据密集型工具的工作时意识到需要这样的东西。我注意到，几乎所有新的应用软件，无论是内部构建的还是第三方的SaaS，都是以浏览器应用的形式交付的，而不是本地的。虽然浏览器比以往任何时候都更强大，但我从经验中知道，工业规模的数据密集型应用程序会带来问题，因为无论是浏览器还是传统的无状态服务器架构都无法提供与大型数据集进行低延迟交互所需的计算资源。我开始和我的朋友Taylor讨论这个问题，他在Datadog和Uber的数据分析和可视化工具工作中也遇到了类似的限制。我们决定联合起来，围绕解决这个问题建立一个公司。<p>我们有两个产品，一个开源包和一个管理平台。开源部分的 Spawner 为 Web 应用程序提供了一个 API，以生成一个会话生命周期的进程。它管理进程的生命周期，通过 HTTPS 公开它，跟踪入站连接，并在它闲置时（即当用户关闭其标签时）关闭它。它是开源的（MIT），可在<a href=\"https://github.com/drifting-in-space/spawner\" rel=\"nofollow\">https://github.com/drifting-in-space/spawner</a>。<p>Jamsocket 是我们的管理平台，其内部使用 Spawner。它提供了相同的 API，但使您无需处理任何群集或网络配置来运送代码。从应用程序开发人员的角度来看，使用它与使用 Netlify 或 Render 等平台相似。你停留在网络堆栈中，永远不必接触Kubernetes。<p>这里有一个例子。想象一下，你做了一个用于调查大型交易数据库中欺诈行为的应用程序。用户想要交互式地过滤、聚合并将数千兆字节的交易可视化为一个图形。你可以把你的代码放在一个容器里并上传到我们的平台上，而不是把所有的数据发送到浏览器上并在那里做这些工作。然后，每当欺诈分析人员打开你的应用程序时，你就会点击我们提供的API，为该分析人员启动一个专门的后台。你的浏览器代码然后直接打开一个WebSocket连接到该后端，当分析师应用过滤器或缩放/平移可视化时，它使用该连接来流转数据。<p>我们与大多数管理平台不同，因为我们给每个用户一个专用程序。也就是说，有一些其他服务确实为每个用户运行长期的进程。在架构上，我们与Agones最为相似。Agones针对的是客户端可以通过UDP与任意IP对话的游戏；我们的目标是希望通过HTTPS直接从浏览器连接到主机名的应用。在Erlang世界中，OTP栈提供了类似的功能，但你必须接受Erlang/Elixir才能得到它的好处；我们完全是语言无关的。Cloudflare Durable Objects支持一种长寿命的进程，但它侧重于围绕程序状态同步的用例，而不是任意的高计算/内存用例。<p>我们有一个基于使用的计费模型，类似于Heroku。我们对你所使用的计算量进行收费，并从中抽成。用量计费的规模为零，所以对于周末的实验来说是可以接近的。我们还没有确定一个价格计划，但我们的目标是提供一个能够运行VS Code的实例（作为一个例子），每小时大约10美分，按比例收费。高内存和高CPU的后端将花费更多，而重度用户将获得批量折扣。我们的目标客户是类似于桌面的 SaaS 应用程序和内部数据工具。<p>如上所述，我们的核心 API 是开源的，可在<a href=\"https://github.com/drifting-in-space/spawner\" rel=\"nofollow\">https://github.com/drifting-in-space/spawner</a>上获得。管理平台处于测试阶段，我们目前正在从等待名单中吸纳用户，以确保我们有足够的服务器容量来扩展。如果你有兴趣，欢迎你在这里注册加入。<a href=\"https://driftingin.space\" rel=\"nofollow\">https://driftingin.space</a>。<p>你是否建立了一个类似的 ",
  "description_zh-Hant": "嗨，HN，我們是Paul和Taylor，我們正在推出Drifting in Space（<a href=\"https://driftingin.space\" rel=\"nofollow\">https://driftingin.space</a>）。我們為基於瀏覽器的性能密集型應用構建服務器軟件。我們可以輕鬆地為您的應用程序的每個用戶提供一個專用的服務器端進程，該進程在用戶打開您的應用程序時啟動，並在用戶關閉標籤時停止。<p>許多高端 Web 應用程序為每個用戶提供一個與服務器端進程的專用連接。這就是他們獲得低延遲的方式，而你需要像成熟的視頻編輯工具和 IDE 這樣的雄心勃勃的產品。這對小型團隊來說很難重現，因為這需要大量的持續工程投資。這就是我們的優勢所在--我們向每個人提供這種架構，所以你可以專注於你的應用而不是它的基礎設施。你可以把它想象成 Heroku，只不過你的每個用戶都有自己的服務器實例。<p>我在一家對沖基金從事數據密集型工具的工作時意識到需要這樣的東西。我注意到，幾乎所有新的應用軟件，無論是內部構建的還是第三方的SaaS，都是以瀏覽器應用的形式交付的，而不是本地的。雖然瀏覽器比以往任何時候都更強大，但我從經驗中知道，工業規模的數據密集型應用程序會帶來問題，因為無論是瀏覽器還是傳統的無狀態服務器架構都無法提供與大型數據集進行低延遲交互所需的計算資源。我開始和我的朋友Taylor討論這個問題，他在Datadog和Uber的數據分析和可視化工具工作中也遇到了類似的限制。我們決定聯合起來，圍繞解決這個問題建立一個公司。<p>我們有兩個產品，一個開源包和一個管理平臺。開源部分的 Spawner 為 Web 應用程序提供了一個 API，以生成一個會話生命週期的進程。它管理進程的生命週期，通過 HTTPS 公開它，跟蹤入站連接，並在它閒置時（即當用戶關閉其標籤時）關閉它。它是開源的（MIT），可在<a href=\"https://github.com/drifting-in-space/spawner\" rel=\"nofollow\">https://github.com/drifting-in-space/spawner</a>。<p>Jamsocket 是我們的管理平臺，其內部使用 Spawner。它提供了相同的 API，但使您無需處理任何群集或網絡配置來運送代碼。從應用程序開發人員的角度來看，使用它與使用 Netlify 或 Render 等平臺相似。你停留在網絡堆棧中，永遠不必接觸Kubernetes。<p>這裡有一個例子。想象一下，你做了一個用於調查大型交易數據庫中欺詐行為的應用程序。用戶想要交互式地過濾、聚合並將數千兆字節的交易可視化為一個圖形。你可以把你的代碼放在一個容器裡並上傳到我們的平臺上，而不是把所有的數據發送到瀏覽器上並在那裡做這些工作。然後，每當欺詐分析人員打開你的應用程序時，你就會點擊我們提供的API，為該分析人員啟動一個專門的後臺。你的瀏覽器代碼然後直接打開一個WebSocket連接到該後端，當分析師應用過濾器或縮放/平移可視化時，它使用該連接來流轉數據。<p>我們與大多數管理平臺不同，因為我們給每個用戶一個專用程序。也就是說，有一些其他服務確實為每個用戶運行長期的進程。在架構上，我們與Agones最為相似。Agones針對的是客戶端可以通過UDP與任意IP對話的遊戲；我們的目標是希望通過HTTPS直接從瀏覽器連接到主機名的應用。在Erlang世界中，OTP棧提供了類似的功能，但你必須接受Erlang/Elixir才能得到它的好處；我們完全是語言無關的。Cloudflare Durable Objects支持一種長壽命的進程，但它側重於圍繞程序狀態同步的用例，而不是任意的高計算/內存用例。<p>我們有一個基於使用的計費模型，類似於Heroku。我們對你所使用的計算量進行收費，並從中抽成。用量計費的規模為零，所以對於週末的實驗來說是可以接近的。我們還沒有確定一個價格計劃，但我們的目標是提供一個能夠運行VS Code的實例（作為一個例子），每小時大約10美分，按比例收費。高內存和高CPU的後端將花費更多，而重度用戶將獲得批量折扣。我們的目標客戶是類似於桌面的 SaaS 應用程序和內部數據工具。<p>如上所述，我們的核心 API 是開源的，可在<a href=\"https://github.com/drifting-in-space/spawner\" rel=\"nofollow\">https://github.com/drifting-in-space/spawner</a>上獲得。管理平臺處於測試階段，我們目前正在從等待名單中吸納用戶，以確保我們有足夠的服務器容量來擴展。如果你有興趣，歡迎你在這裡註冊加入。<a href=\"https://driftingin.space\" rel=\"nofollow\">https://driftingin.space</a>。<p>你是否建立了一個類似的 "
}