{
  "@type": "NewsArticle",
  "identifier": "2022--03--01--en--myfeed--HackerNews--NewsArticle--30515582",
  "url": "https://news.ycombinator.com/item?id=30515582",
  "headline": "Show HN: Brackit – a retargetable JSONiq based query engine for JSON",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "Hi all,<p>Sebastian and his students did a tremendous job creating Brackit[1] in the first place as a retargetable query engine for different data stores. They worked hard to optimize aggregations and joins. Despite its clear database query engine routes, it's furthermore useable as a standalone ad-hoc in-memory query engine.<p>Sebastian did his research for his Ph.D. at the TU-Kaiserslautern at the database systems group of Theo Härder. Theo Härder coined the well-known acronym ACID with Andreas Reuter, the desired properties of transactions.<p>As he's currently not maintaining the project anymore, I stepped up and forked the project a couple of years ago. I'm using it for my evolutionary, immutable data store SirixDB[2], which stores the entire history of your JSON data in small-sized snapshots in an append-only file (tailored binary format similar to BSON). It's exceptionally well suited for audits, undo operations, and sophisticated analytical time travel queries.<p>I've changed a lot of stuff, such that Brackit is getting more and more compatible with the JSONiq query language standard, added JSONiq update primitives, and fixed several bugs. Furthermore, I've added temporal extension functions and temporal XPath axis in SirixDB, index rewrite rules, etc. pp.<p>As Brackit can query XML, we're also able to transform XML data to JSON and vice versa.<p>Moshe and I are working on a  Jupyter Notebook / Tutorial[3] for interactive queries.<p>We're looking forward to your bug reports, issues, and questions. Contributions are, of course, highly welcome. Maybe even implementations for other data stores or common query optimizations.<p>Furthermore, we'd gladly see further (university-based?) research.<p>It should, for instance, be possible to add vector instructions in the future, as the query engine is already set-oriented and processes sets of tuples for the so-called FLWOR expressions (see JSONiq). Brackit rewrites FLWOR expression trees in the AST to a pipeline of operations to port optimizations from relational query engines for efficient join processing and aggregate expressions. Furthermore, certain parts of the queries are parallelizable, as detailed in Sebastian's thesis. We also envision a stage for the compiler to use distributed processing (first research used MapReduce, but we can now use better-suited approaches, of course).<p>Kind regards\nJohannes<p>[1] https://github.com/sirixdb/brackit\n[2] https://sirix.io | https://github.com/sirixdb/sirix\n[3] https://colab.research.google.com/drive/19eC-UfJVm_gCjY--koOWN50sgiFa5hSC",
  "keywords": [
    "Show HN"
  ],
  "genre": "Show HN",
  "author": {
    "@type": "Person",
    "name": "lichtenberger",
    "url": "https://news.ycombinator.com/user?id=lichtenberger"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=30515582",
  "sameAs": "https://news.ycombinator.com/item?id=30515582",
  "dateCreated": "2022-03-01T15:52:14.053Z",
  "datePublished": "2022-03-01T15:49:17.000Z",
  "dateModified": "2022-03-01T15:52:14.053Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 1
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 0
    }
  ],
  "headline_zh-Hans": "Show HN: Brackit - 基于JSONiq的可重定向JSON查询引擎",
  "headline_zh-Hant": "Show HN: Brackit - 基於JSONiq的可重定向JSON查詢引擎",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "大家好，<p>Sebastian和他的学生在创建Brackit[1]时做了大量的工作，首先是作为一个针对不同数据存储的可重定向查询引擎。他们努力地优化聚合和连接。尽管它有明确的数据库查询引擎路线，但它还可以作为一个独立的临时内存查询引擎使用。<p>Sebastian在TU-Kaiserslautern的Theo Härder的数据库系统小组完成了他的博士研究。Theo Härder与Andreas Reuter共同创造了著名的缩写ACID，即事务的理想属性。<p>由于他目前不再维护该项目，我在几年前挺身而出，分叉了该项目。我把它用于我的进化的、不可改变的数据存储SirixDB[2]，它把你的JSON数据的整个历史以小尺寸的快照存储在一个仅有附录的文件中（定制的二进制格式类似于BSON）。它特别适合审计、撤销操作和复杂的分析性时间旅行查询。<p>我改变了很多东西，比如Brackit与JSONiq查询语言标准越来越兼容，增加了JSONiq更新原语，并修复了几个错误。此外，我还在SirixDB中添加了时态扩展函数和时态XPath轴，索引重写规则等。<p>由于Brackit可以查询XML，我们也能够将XML数据转换为JSON，反之亦然。<p>Moshe和我正在开发一个Jupyter笔记本/教程[3]，用于互动查询。<p>我们期待着你的错误报告、问题和疑问。当然，我们也非常欢迎大家的贡献。<p>此外，我们很乐意看到进一步的（基于大学的）研究。<p>例如，未来应该有可能添加矢量指令，因为查询引擎已经是面向集合的，并为所谓的FLWOR表达式处理图元集合（见JSONiq）。Brackit将AST中的FLWOR表达式树重写为操作流水线，以移植关系型查询引擎的优化，实现高效的连接处理和聚合表达。此外，查询的某些部分是可并行的，详见Sebastian的论文。我们还设想了一个阶段，让编译器使用分布式处理（第一次研究使用了MapReduce，但我们现在当然可以使用更适合的方法）。<p>诚挚问候\nJohannes<p>[1] https://github.com/sirixdb/brackit\n[2] https://sirix.io | https://github.com/sirixdb/sirix\n[3] https://colab.research.google.com/drive/19eC-UfJVm_gCjY--koOWN50sgiFa5hSC",
  "description_zh-Hant": "大家好，<p>Sebastian和他的學生在創建Brackit[1]時做了大量的工作，首先是作為一個針對不同數據存儲的可重定向查詢引擎。他們努力地優化聚合和連接。儘管它有明確的數據庫查詢引擎路線，但它還可以作為一個獨立的臨時內存查詢引擎使用。<p>Sebastian在TU-Kaiserslautern的Theo Härder的數據庫系統小組完成了他的博士研究。Theo Härder與Andreas Reuter共同創造了著名的縮寫ACID，即事務的理想屬性。<p>由於他目前不再維護該項目，我在幾年前挺身而出，分叉了該項目。我把它用於我的進化的、不可改變的數據存儲SirixDB[2]，它把你的JSON數據的整個歷史以小尺寸的快照存儲在一個僅有附錄的文件中（定製的二進制格式類似於BSON）。它特別適合審計、撤銷操作和複雜的分析性時間旅行查詢。<p>我改變了很多東西，比如Brackit與JSONiq查詢語言標準越來越兼容，增加了JSONiq更新原語，並修復了幾個錯誤。此外，我還在SirixDB中添加了時態擴展函數和時態XPath軸，索引重寫規則等。<p>由於Brackit可以查詢XML，我們也能夠將XML數據轉換為JSON，反之亦然。<p>Moshe和我正在開發一個Jupyter筆記本/教程[3]，用於互動查詢。<p>我們期待著你的錯誤報告、問題和疑問。當然，我們也非常歡迎大家的貢獻。<p>此外，我們很樂意看到進一步的（基於大學的）研究。<p>例如，未來應該有可能添加矢量指令，因為查詢引擎已經是面向集合的，併為所謂的FLWOR表達式處理圖元集合（見JSONiq）。Brackit將AST中的FLWOR表達式樹重寫為操作流水線，以移植關係型查詢引擎的優化，實現高效的連接處理和聚合表達。此外，查詢的某些部分是可並行的，詳見Sebastian的論文。我們還設想了一個階段，讓編譯器使用分佈式處理（第一次研究使用了MapReduce，但我們現在當然可以使用更適合的方法）。<p>誠摯問候\nJohannes<p>[1] https://github.com/sirixdb/brackit\n[2] https://sirix.io | https://github.com/sirixdb/sirix\n[3] https://colab.research.google.com/drive/19eC-UfJVm_gCjY--koOWN50sgiFa5hSC"
}