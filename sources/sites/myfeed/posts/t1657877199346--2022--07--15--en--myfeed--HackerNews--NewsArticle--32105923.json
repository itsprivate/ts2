{
  "@type": "NewsArticle",
  "identifier": "2022--07--15--en--myfeed--HackerNews--NewsArticle--32105923",
  "url": "https://news.ycombinator.com/item?id=32105923",
  "headline": "The most important code linting rule: max-params",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "Let me ask you: What do you think this code does?<p><pre><code>    resizeImage(imagePath, 300, 200, true, true, 1)\n</code></pre>\nIt resizes image... but what exactly does it do? For the most part, we cannot tell without looking up the function definition.<p>Let's say you are reviewing a PR and it includes this change:<p><pre><code>    -resizeImage(imagePath, 300, 200, true, true, 1)\n    +resizeImage(imagePath, 300, 200, false, true, 1)\n</code></pre>\nCan you confidently say what is the impact of this change? For the most part... no. You need to know what each positional argument does.<p>Let's say you know that the interface is:<p><pre><code>    function resizeImage(\n      imagePath: string,\n      width: number,\n      height: number,\n      upscale: boolean,\n      crop: boolean,\n      quality: number,\n    ): Promise&lt;Buffer&gt;\n</code></pre>\nBut now a PR introduces a change to the parameter order (e.g. to make it consistent with other functions):<p><pre><code>    function resizeImage(\n      imagePath: string,\n      width: number,\n      height: number,\n    +  crop: boolean,\n      upscale: boolean,\n    -  crop: boolean,\n      quality: number,\n    ): Promise&lt;Buffer&gt;\n</code></pre>\nHow do you review this change? Sure, reviewing the interface diff is easy, but what about the dozens or hundreds of diffs that update function invocation?<p><pre><code>    -resizeImage(imagePath, 300, 200, true, false, 1)\n    +resizeImage(imagePath, 300, 200, false, true, 1)\n    resizeImage(imagePath, 300, 200, false, false, 1)\n    -resizeImage(imagePath, 300, 200, false, true, 1)\n    +resizeImage(imagePath, 300, 200, false, false, 1)\n    -resizeImage(imagePath, 300, 200, true, false, 1)\n    +resizeImage(imagePath, 300, 200, false, true, 1)\n</code></pre>\nHopefully the problem is self-explanatory: Positional arguments create a breading ground for hard and even impossible bugs to catch/debug/fix, esp. when code needs to be refactored. Fear not though as there is a better way.<p>Let's start from the start, but this time use a single-object parameter:<p><pre><code>    resizeImage({\n      imagePath,\n      width: 300,\n      height: 200,\n      upscale: true,\n      crop: false,\n      quality: 1,\n    })\n</code></pre>\nCan you tell what is the intention behind this code? Yes, you can get a good sense, even if you are not familiar with the implementation.<p>Can you easily refactor the interface? Yes, linter will warn you if contract is not satisfied.<p>We end up with positional arguments because they feel the most natural to start with. However, as functions grow in scope, what started as a simple function with 1-2 arguments becomes an unreadable mess.<p>This is where [`max-params`](https://eslint.org/docs/latest/rules/max-params) comes to the rescue. Simply adding an ESLint rule that restricts having functions with more than X parameters ensures that your code remains legible and easy to refactor as your codebase scales.",
  "keywords": [],
  "author": {
    "@type": "Person",
    "name": "gajus",
    "url": "https://news.ycombinator.com/user?id=gajus"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=32105923",
  "sameAs": "https://news.ycombinator.com/item?id=32105923",
  "dateCreated": "2022-07-15T09:26:39.346Z",
  "datePublished": "2022-07-15T08:13:40.000Z",
  "dateModified": "2022-07-15T09:26:39.346Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 2
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 1
    }
  ],
  "headline_zh-Hans": "最重要的代码润色规则：最大参数\n",
  "headline_zh-Hant": "最重要的代碼潤色規則：最大參數\n",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "Let me ask you: What do you think this code does?<p><pre><code> resizeImage(imagePath, 300, 200, true, true, 1)\n</code></pre>\nIt resizes image... but what exactly does it do? For the most part, we cannot tell without looking up the function definition.<p>Let's say you are reviewing a PR and it includes this change:<p><pre><code> -resizeImage(imagePath, 300, 200, true, true, 1)\n    +resizeImage(imagePath, 300, 200, false, true, 1)\n</code></pre>\nCan you confidently say what is the impact of this change? For the most part... no. You need to know what each positional argument does.<p>Let's say you know that the interface is:<p><pre><code> function resizeImage(\n      imagePath: string,\n      width: number,\n      height: number,\n      upscale: boolean,\n      crop: boolean,\n      quality: number,\n    ): Promise&lt;Buffer&gt;\n</code></pre>\nBut now a PR introduces a change to the parameter order (e.g. to make it consistent with other functions):<p><pre><code> function resizeImage(\n      imagePath: string,\n      width: number,\n      height: number,\n    + crop: boolean,\n      upscale: boolean,\n    - crop: boolean,\n      quality: number,\n    ): Promise&lt;Buffer&gt;\n</code></pre>\nHow do you review this change? Sure, reviewing the interface diff is easy, but what about the dozens or hundreds of diffs that update function invocation?<p><pre><code> -resizeImage(imagePath, 300, 200, true, false, 1)\n    +resizeImage(imagePath, 300, 200, false, true, 1)\n    resizeImage(imagePath, 300, 200, false, false, 1)\n    -resizeImage(imagePath, 300, 200, false, true, 1)\n    +resizeImage(imagePath, 300, 200, false, false, 1)\n    -resizeImage(imagePath, 300, 200, true, false, 1)\n    +resizeImage(imagePath, 300, 200, false, true, 1)\n</code></pre>\nHopefully the problem is self-explanatory: Positional arguments create a breading ground for hard and even impossible bugs to catch/debug/fix, esp. when code needs to be refactored. Fear not though as there is a better way.<p>Let's start from the start, but this time use a single-object parameter:<p><pre><code> resizeImage({\n      imagePath,\n      width: 300,\n      height: 200,\n      upscale: true,\n      crop: false,\n      quality: 1,\n    })\n</code></pre>\nCan you tell what is the intention behind this code? Yes, you can get a good sense, even if you are not familiar with the implementation.<p>Can you easily refactor the interface? Yes, linter will warn you if contract is not satisfied.<p>We end up with positional arguments because they feel the most natural to start with. However, as functions grow in scope, what started as a simple function with 1-2 arguments becomes an unreadable mess.<p>This is where [`max-params`](https://eslint.org/docs/latest/rules/max-params) comes to the rescue. Simply adding an ESLint rule that restricts having functions with more than X parameters ensures that your code remains legible and easy to refactor as your codebase scales.\n",
  "description_zh-Hant": "Let me ask you: What do you think this code does?<p><pre><code> resizeImage(imagePath, 300, 200, true, true, 1)\n</code></pre>\nIt resizes image... but what exactly does it do? For the most part, we cannot tell without looking up the function definition.<p>Let's say you are reviewing a PR and it includes this change:<p><pre><code> -resizeImage(imagePath, 300, 200, true, true, 1)\n    +resizeImage(imagePath, 300, 200, false, true, 1)\n</code></pre>\nCan you confidently say what is the impact of this change? For the most part... no. You need to know what each positional argument does.<p>Let's say you know that the interface is:<p><pre><code> function resizeImage(\n      imagePath: string,\n      width: number,\n      height: number,\n      upscale: boolean,\n      crop: boolean,\n      quality: number,\n    ): Promise&lt;Buffer&gt;\n</code></pre>\nBut now a PR introduces a change to the parameter order (e.g. to make it consistent with other functions):<p><pre><code> function resizeImage(\n      imagePath: string,\n      width: number,\n      height: number,\n    + crop: boolean,\n      upscale: boolean,\n    - crop: boolean,\n      quality: number,\n    ): Promise&lt;Buffer&gt;\n</code></pre>\nHow do you review this change? Sure, reviewing the interface diff is easy, but what about the dozens or hundreds of diffs that update function invocation?<p><pre><code> -resizeImage(imagePath, 300, 200, true, false, 1)\n    +resizeImage(imagePath, 300, 200, false, true, 1)\n    resizeImage(imagePath, 300, 200, false, false, 1)\n    -resizeImage(imagePath, 300, 200, false, true, 1)\n    +resizeImage(imagePath, 300, 200, false, false, 1)\n    -resizeImage(imagePath, 300, 200, true, false, 1)\n    +resizeImage(imagePath, 300, 200, false, true, 1)\n</code></pre>\nHopefully the problem is self-explanatory: Positional arguments create a breading ground for hard and even impossible bugs to catch/debug/fix, esp. when code needs to be refactored. Fear not though as there is a better way.<p>Let's start from the start, but this time use a single-object parameter:<p><pre><code> resizeImage({\n      imagePath,\n      width: 300,\n      height: 200,\n      upscale: true,\n      crop: false,\n      quality: 1,\n    })\n</code></pre>\nCan you tell what is the intention behind this code? Yes, you can get a good sense, even if you are not familiar with the implementation.<p>Can you easily refactor the interface? Yes, linter will warn you if contract is not satisfied.<p>We end up with positional arguments because they feel the most natural to start with. However, as functions grow in scope, what started as a simple function with 1-2 arguments becomes an unreadable mess.<p>This is where [`max-params`](https://eslint.org/docs/latest/rules/max-params) comes to the rescue. Simply adding an ESLint rule that restricts having functions with more than X parameters ensures that your code remains legible and easy to refactor as your codebase scales.\n"
}