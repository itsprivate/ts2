{
  "@type": "NewsArticle",
  "identifier": "2022--07--18--en--myfeed--HackerNews--NewsArticle--32133392",
  "url": "https://news.ycombinator.com/item?id=32133392",
  "headline": "Why should I relearn algorithms?",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "I read Dan Luu's programming books page recently, on which it says about algorithms: &quot;Why should you care? Well, there's the pragmatic argument: even if you never use this stuff in your job, most of the best paying companies will quiz you on this stuff in interviews. On the non-bullshit side of things, I find algorithms to be useful in the same way I find math to be useful. The probability of any particular algorithm being useful for any particular problem is low, but having a general picture of what kinds of problems are solved problems, what kinds of problems are intractable, and when approximations will be effective, is often useful.&quot;<p>I learned algorithms in college, many years ago. I still have a good idea of when to use data structures, generally. I probably couldn't pass a FAANG-style interview without a couple months prep now, despite giving them every other week. I couldn't tell you when to use a red-black tree over a b-tree anymore. Frankly, as a dime-a-dozen megacorp SWE, that's not really something that would come up in daily work. IME, management isn't going to give you time to care about performance specifics - maybe, if there's a library that offers a convenient API and some deceptive benchmark graphs, you use that. I think I've used a prefix trie, once, in my entire professional career. The rest is just standardlib abstractions where I don't really care about what's happening below. Someone much smarter than me is making optimizations based on the latest papers for any given sorted() implementation.<p>What other motivation is there to relearn algorithms except for clearing the interview hurdle? Especially when free time is limited, and you could instead _finally_ get around to reading Designing Data-Intensive Application or Crafting Interpreters, learning Rust/Go/CultLang, or dipping your toes into something &quot;fun&quot; like reverse engineering?",
  "keywords": [],
  "author": {
    "@type": "Person",
    "name": "why_algorithms",
    "url": "https://news.ycombinator.com/user?id=why_algorithms"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=32133392",
  "sameAs": "https://news.ycombinator.com/item?id=32133392",
  "dateCreated": "2022-07-18T02:26:32.101Z",
  "datePublished": "2022-07-18T01:12:25.000Z",
  "dateModified": "2022-07-18T02:26:32.101Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 2
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 2
    }
  ],
  "headline_zh-Hans": "我为什么要重新学习算法？\n",
  "headline_zh-Hant": "我為什麼要重新學習算法？\n",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "我最近读了Dan Luu的编程书籍页面，上面说到算法：&quot;你为什么要关心？好吧，有一个务实的论点：即使你在工作中从来没有使用过这些东西，大多数薪水最高的公司会在面试中询问你这些东西。在非废话的方面，我发现算法是有用的，就像我发现数学是有用的一样。任何特定算法对任何特定问题有用的概率都很低，但对什么样的问题是可解决的问题，什么样的问题是难以解决的，以及什么时候近似值会有效，有一个总体的了解往往是有用的。我对何时使用数据结构仍有很好的认识，一般来说。现在，如果没有几个月的准备，我可能无法通过FAANG式的面试，尽管我每隔一周就去面试。我再也不能告诉你什么时候该用红黑树而不是B树了。坦率地说，作为一个微不足道的大公司的SWE，这并不是日常工作中真正会出现的东西。IME，管理层不会给你时间去关心性能的细节--也许，如果有一个库提供了一个方便的API和一些欺骗性的基准图，你会使用它。我想在我的整个职业生涯中，我只用过一次前缀TREE。其余的只是标准库的抽象，我并不关心下面发生了什么。比我聪明得多的人正在根据最新的论文对任何给定的sorted()实现进行优化。<p>除了通过面试这一关，还有什么动机来重新学习算法？尤其是在空闲时间有限的情况下，你可以最终去阅读《设计数据密集型应用程序》或《制作解释器》，学习Rust/Go/CultLang，或者涉足一些&quot;有趣&quot;的东西，比如反向工程？\n",
  "description_zh-Hant": "我最近讀了Dan Luu的編程書籍頁面，上面說到算法：&quot;你為什麼要關心？好吧，有一個務實的論點：即使你在工作中從來沒有使用過這些東西，大多數薪水最高的公司會在面試中詢問你這些東西。在非廢話的方面，我發現算法是有用的，就像我發現數學是有用的一樣。任何特定算法對任何特定問題有用的概率都很低，但對什麼樣的問題是可解決的問題，什麼樣的問題是難以解決的，以及什麼時候近似值會有效，有一個總體的瞭解往往是有用的。我對何時使用數據結構仍有很好的認識，一般來說。現在，如果沒有幾個月的準備，我可能無法通過FAANG式的面試，儘管我每隔一週就去面試。我再也不能告訴你什麼時候該用紅黑樹而不是B樹了。坦率地說，作為一個微不足道的大公司的SWE，這並不是日常工作中真正會出現的東西。IME，管理層不會給你時間去關心性能的細節--也許，如果有一個庫提供了一個方便的API和一些欺騙性的基準圖，你會使用它。我想在我的整個職業生涯中，我只用過一次前綴TREE。其餘的只是標準庫的抽象，我並不關心下面發生了什麼。比我聰明得多的人正在根據最新的論文對任何給定的sorted()實現進行優化。<p>除了通過面試這一關，還有什麼動機來重新學習算法？尤其是在空閒時間有限的情況下，你可以最終去閱讀《設計數據密集型應用程序》或《製作解釋器》，學習Rust/Go/CultLang，或者涉足一些&quot;有趣&quot;的東西，比如反向工程？\n"
}