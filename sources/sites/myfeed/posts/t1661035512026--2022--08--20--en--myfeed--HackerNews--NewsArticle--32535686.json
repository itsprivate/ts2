{
  "@type": "NewsArticle",
  "identifier": "2022--08--20--en--myfeed--HackerNews--NewsArticle--32535686",
  "url": "https://news.ycombinator.com/item?id=32535686",
  "headline": "Show HN: Linkly",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "Hi folks,<p>My friend and I wanted to show a macOS app we wrote. The app allows users to search their Chrome history and insert a link from the search results in any text box. Think the macOS emoji box (Ctrl + Command + Space), but for your Chrome history.<p>For the frontend, we use a combination of React and Electron, mainly for developer velocity. We used Figma to iterate on the visual design.<p>One the challenges was getting the pane to appear next to the user’s caret as they are typing. Currently, we place the pane at the user’s last cursor location. You might notice some quirks in Linkly that are also shared with macOS' emoji box. For example, in many apps, you'll end up with two flashing carets: one in the app's text box and another in Linkly's text input field.<p>The Chrome history files are SQLite databases, stored in ~/Library/Application Support/Google/Chrome/. Each Chrome profile has its own history file. We make copies of these SQLite databases and build full-text search indices using SQLite's FTS5 module (<a href=\"https://www.sqlite.org/fts5.html\" rel=\"nofollow\">https://www.sqlite.org/fts5.html</a>). The actual search query is a bit of a hack. We just split your query on whitespace, append &quot;*&quot; to each &quot;token&quot;, and send it along to SQLite. This somewhat mimics VS Code's search functionality where each token is treated as a substring. In the future, we might parse the entire query per SQLite's grammar and rewrite it so it more closely matches VS Code's behavior and so we can disable some of SQLite's search capabilities that don't make sense for Linkly (e.g., &quot;my_column:x&quot;).<p>Please let us know what you think!",
  "keywords": [
    "Show HN"
  ],
  "genre": "Show HN",
  "author": {
    "@type": "Person",
    "name": "aryann",
    "url": "https://news.ycombinator.com/user?id=aryann"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=32535686",
  "sameAs": "https://www.linkly.at/",
  "dateCreated": "2022-08-20T22:45:12.026Z",
  "datePublished": "2022-08-20T22:25:09.000Z",
  "dateModified": "2022-08-20T22:45:12.026Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 4
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 1
    }
  ],
  "headline_zh-Hans": "Show HN: 琳克丽\n",
  "headline_zh-Hant": "Show HN: 琳克麗\n",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "Hi folks,<p>My friend and I wanted to show a macOS app we wrote. The app allows users to search their Chrome history and insert a link from the search results in any text box. Think the macOS emoji box (Ctrl + Command + Space), but for your Chrome history.<p>For the frontend, we use a combination of React and Electron, mainly for developer velocity. We used Figma to iterate on the visual design.<p>One the challenges was getting the pane to appear next to the user’s caret as they are typing. Currently, we place the pane at the user’s last cursor location. You might notice some quirks in Linkly that are also shared with macOS' emoji box. For example, in many apps, you'll end up with two flashing carets: one in the app's text box and another in Linkly's text input field.<p>The Chrome history files are SQLite databases, stored in ~/Library/Application Support/Google/Chrome/. Each Chrome profile has its own history file. We make copies of these SQLite databases and build full-text search indices using SQLite's FTS5 module (<a href=\"https://www.sqlite.org/fts5.html\" rel=\"nofollow\">https://www.sqlite.org/fts5.html</a>). The actual search query is a bit of a hack. We just split your query on whitespace, append &quot;*&quot; to each &quot;token&quot;, and send it along to SQLite. 这在一定程度上模仿了VS Code的搜索功能，每个标记都被当作一个子串。在未来，我们可能会根据SQLite的语法解析整个查询，并重写它，使其更接近于VS Code的行为，这样我们就可以禁用一些对Linkly没有意义的SQLite的搜索功能（例如，&quot;my_column:x&quot;）。\n",
  "description_zh-Hant": "Hi folks,<p>My friend and I wanted to show a macOS app we wrote. The app allows users to search their Chrome history and insert a link from the search results in any text box. Think the macOS emoji box (Ctrl + Command + Space), but for your Chrome history.<p>For the frontend, we use a combination of React and Electron, mainly for developer velocity. We used Figma to iterate on the visual design.<p>One the challenges was getting the pane to appear next to the user’s caret as they are typing. Currently, we place the pane at the user’s last cursor location. You might notice some quirks in Linkly that are also shared with macOS' emoji box. For example, in many apps, you'll end up with two flashing carets: one in the app's text box and another in Linkly's text input field.<p>The Chrome history files are SQLite databases, stored in ~/Library/Application Support/Google/Chrome/. Each Chrome profile has its own history file. We make copies of these SQLite databases and build full-text search indices using SQLite's FTS5 module (<a href=\"https://www.sqlite.org/fts5.html\" rel=\"nofollow\">https://www.sqlite.org/fts5.html</a>). The actual search query is a bit of a hack. We just split your query on whitespace, append &quot;*&quot; to each &quot;token&quot;, and send it along to SQLite. 這在一定程度上模仿了VS Code的搜索功能，每個標記都被當作一個子串。在未來，我們可能會根據SQLite的語法解析整個查詢，並重寫它，使其更接近於VS Code的行為，這樣我們就可以禁用一些對Linkly沒有意義的SQLite的搜索功能（例如，&quot;my_column:x&quot;）。\n"
}