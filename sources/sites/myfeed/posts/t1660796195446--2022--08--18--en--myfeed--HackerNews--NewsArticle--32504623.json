{
  "@type": "NewsArticle",
  "identifier": "2022--08--18--en--myfeed--HackerNews--NewsArticle--32504623",
  "url": "https://news.ycombinator.com/item?id=32504623",
  "headline": "Refactoring Large Codebases",
  "publisher": {
    "@type": "Organization",
    "name": "HackerNews",
    "url": "https://news.ycombinator.com",
    "logo": "https://hn.buzzing.cc/avatar.png"
  },
  "description": "Over my career I've refactored a handful of gigantic codebases and I have a few tips.<p>First: Version control _everything_. I mean, remove `.gitignore`, and add everything to git index before you start refactoring. The worst that can happen is when you accidentally make a change, everything breaks, and you have no way to recover to a working state.<p>Second: If you don't already have them, write compatibility tests for all public interfaces. It is easy to fall into trap of refactoring code and running a simple program to ensure that it works, but if it is a large application, chances are that your simple program does not cover all the edge cases.<p>Third: Use code coverage and eliminate all dead code paths before you start refactoring. When undergoing a refactor, chances are that you don't want to port everything: backwards compatibility, patches, etc. Code coverage reports allow you to understand exactly what is and isn't used by your tests on your target platforms.<p>Fourth: Make a list. I start refactors by scanning the codebase without making any changes and just writing a list of things that I would like to change. Planning allows to better understand the scope and feel like you are progressing in what may be a long endeavor.<p>Five: Make one change at a time. That's where the list comes into play. It is easy to start just going file by file and making changes to everything, but you are not setting up yourself for success, esp. if there are thousands of files. Doing 1 problem at a time allows you to be focused and efficient solving one problem.<p>Six: Document breaking changes and design decisions as you refactor. Whatever you document before the guiding principles for yourself and serve as a memo for future maintainers of the codebase.<p>These are the things/ideas I follow when refactoring large codebases. What about you?",
  "keywords": [],
  "author": {
    "@type": "Person",
    "name": "punkpeye",
    "url": "https://news.ycombinator.com/user?id=punkpeye"
  },
  "discussionUrl": "https://news.ycombinator.com/item?id=32504623",
  "sameAs": "https://news.ycombinator.com/item?id=32504623",
  "dateCreated": "2022-08-18T04:16:35.446Z",
  "datePublished": "2022-08-18T02:42:39.000Z",
  "dateModified": "2022-08-18T04:16:35.446Z",
  "interactionStatistic": [
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "LikeAction"
      },
      "userInteractionCount": 2
    },
    {
      "@type": "InteractionCounter",
      "interactionType": {
        "@type": "CommentAction"
      },
      "userInteractionCount": 3
    }
  ],
  "headline_zh-Hans": "重构大型代码库\n",
  "headline_zh-Hant": "重構大型代碼庫\n",
  "@context": [
    "https://schema.org",
    {
      "@vocab": "http://schema.org/",
      "@language": "en",
      "headline_zh-Hans": {
        "@id": "headline",
        "@language": "zh-Hans"
      },
      "headline_zh-Hant": {
        "@id": "headline",
        "@language": "zh-Hant"
      },
      "@version": 1.1,
      "description_zh-Hans": {
        "@id": "description",
        "@language": "zh-Hans"
      },
      "description_zh-Hant": {
        "@id": "description",
        "@language": "zh-Hant"
      }
    }
  ],
  "description_zh-Hans": "在我的职业生涯中，我已经重构了一些巨大的代码库，我有一些提示。版本控制_所有东西。我的意思是，删除`.gitignore`，并在你开始重构之前将所有东西添加到git index。最糟糕的情况是，当你不小心做了一个改动，所有东西都坏了，而你没有办法恢复到工作状态。<p>第二：如果你还没有，为所有公共接口编写兼容性测试。我们很容易陷入重构代码和运行简单程序以确保其工作的陷阱，但如果是一个大型的应用程序，你的简单程序很可能没有涵盖所有的边缘情况。<p>第三：在你开始重构之前，使用代码覆盖并消除所有死代码路径。在进行重构时，有可能你并不想移植所有的东西：向后兼容、补丁等。代码覆盖率报告使你能够准确地了解在目标平台上你的测试使用了什么和没有使用什么。<p>第四：列一个清单。我在开始重构时，会在不做任何改动的情况下扫描代码库，只是写一份我想改动的东西的清单。计划可以让我们更好地了解范围，并感觉到你在可能是一个漫长的努力中取得了进展。<p>第五。一次只做一个改变。这就是清单发挥作用的地方。开始时很容易逐个文件并对所有文件进行修改，但你并没有为自己的成功做好准备，特别是如果有成千上万的文件。一次做一个问题，可以让你集中精力，高效地解决一个问题。在你重构的过程中，要记录突发变化和设计决定。无论你记录的是什么，都是你自己的指导原则，并作为未来代码库维护者的备忘录。<p>这些是我在重构大型代码库时遵循的事情/理念。你呢？\n",
  "description_zh-Hant": "在我的職業生涯中，我已經重構了一些巨大的代碼庫，我有一些提示。版本控制_所有東西。我的意思是，刪除`.gitignore`，並在你開始重構之前將所有東西添加到git index。最糟糕的情況是，當你不小心做了一個改動，所有東西都壞了，而你沒有辦法恢復到工作狀態。<p>第二：如果你還沒有，為所有公共接口編寫兼容性測試。我們很容易陷入重構代碼和運行簡單程序以確保其工作的陷阱，但如果是一個大型的應用程序，你的簡單程序很可能沒有涵蓋所有的邊緣情況。<p>第三：在你開始重構之前，使用代碼覆蓋並消除所有死代碼路徑。在進行重構時，有可能你並不想移植所有的東西：向後兼容、補丁等。代碼覆蓋率報告使你能夠準確地瞭解在目標平臺上你的測試使用了什麼和沒有使用什麼。<p>第四：列一個清單。我在開始重構時，會在不做任何改動的情況下掃描代碼庫，只是寫一份我想改動的東西的清單。計劃可以讓我們更好地瞭解範圍，並感覺到你在可能是一個漫長的努力中取得了進展。<p>第五。一次只做一個改變。這就是清單發揮作用的地方。開始時很容易逐個文件並對所有文件進行修改，但你並沒有為自己的成功做好準備，特別是如果有成千上萬的文件。一次做一個問題，可以讓你集中精力，高效地解決一個問題。在你重構的過程中，要記錄突發變化和設計決定。無論你記錄的是什麼，都是你自己的指導原則，並作為未來代碼庫維護者的備忘錄。<p>這些是我在重構大型代碼庫時遵循的事情/理念。你呢？\n"
}