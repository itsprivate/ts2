import { Encodings } from "./_node.ts";
import { indexOf } from "../../bytes/mod.ts";
export function numberToBytes(n) {
    if (n === 0)
        return new Uint8Array([0]);
    const bytes = [];
    bytes.unshift(n & 255);
    while (n >= 256) {
        n = n >>> 8;
        bytes.unshift(n & 255);
    }
    return new Uint8Array(bytes);
}
function findLastIndex(targetBuffer, buffer, offset) {
    offset = offset > targetBuffer.length ? targetBuffer.length : offset;
    const searchableBuffer = targetBuffer.slice(0, offset + buffer.length);
    const searchableBufferLastIndex = searchableBuffer.length - 1;
    const bufferLastIndex = buffer.length - 1;
    let lastMatchIndex = -1;
    let matches = 0;
    let index = -1;
    for (let x = 0; x <= searchableBufferLastIndex; x++) {
        if (searchableBuffer[searchableBufferLastIndex - x] ===
            buffer[bufferLastIndex - matches]) {
            if (lastMatchIndex === -1) {
                lastMatchIndex = x;
            }
            matches++;
        }
        else {
            matches = 0;
            if (lastMatchIndex !== -1) {
                x = lastMatchIndex + 1;
                lastMatchIndex = -1;
            }
            continue;
        }
        if (matches === buffer.length) {
            index = x;
            break;
        }
    }
    if (index === -1)
        return index;
    return searchableBufferLastIndex - index;
}
function indexOfBuffer(targetBuffer, buffer, byteOffset, encoding, forwardDirection) {
    if (!Encodings[encoding] === undefined) {
        throw new Error(`Unknown encoding code ${encoding}`);
    }
    if (!forwardDirection) {
        if (byteOffset < 0) {
            byteOffset = targetBuffer.length + byteOffset;
        }
        if (buffer.length === 0) {
            return byteOffset <= targetBuffer.length
                ? byteOffset
                : targetBuffer.length;
        }
        return findLastIndex(targetBuffer, buffer, byteOffset);
    }
    if (buffer.length === 0) {
        return byteOffset <= targetBuffer.length ? byteOffset : targetBuffer.length;
    }
    return indexOf(targetBuffer, buffer, byteOffset);
}
function indexOfNumber(targetBuffer, number, byteOffset, forwardDirection) {
    const bytes = numberToBytes(number);
    if (bytes.length > 1) {
        throw new Error("Multi byte number search is not supported");
    }
    return indexOfBuffer(targetBuffer, numberToBytes(number), byteOffset, Encodings.UTF8, forwardDirection);
}
export default { indexOfBuffer, indexOfNumber };
export { indexOfBuffer, indexOfNumber };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiYnVmZmVyLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsiYnVmZmVyLnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUFBLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSxZQUFZLENBQUM7QUFDdkMsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBRTdDLE1BQU0sVUFBVSxhQUFhLENBQUMsQ0FBUztJQUNyQyxJQUFJLENBQUMsS0FBSyxDQUFDO1FBQUUsT0FBTyxJQUFJLFVBQVUsQ0FBQyxDQUFDLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFFeEMsTUFBTSxLQUFLLEdBQUcsRUFBRSxDQUFDO0lBQ2pCLEtBQUssQ0FBQyxPQUFPLENBQUMsQ0FBQyxHQUFHLEdBQUcsQ0FBQyxDQUFDO0lBQ3ZCLE9BQU8sQ0FBQyxJQUFJLEdBQUcsRUFBRTtRQUNmLENBQUMsR0FBRyxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQ1osS0FBSyxDQUFDLE9BQU8sQ0FBQyxDQUFDLEdBQUcsR0FBRyxDQUFDLENBQUM7S0FDeEI7SUFDRCxPQUFPLElBQUksVUFBVSxDQUFDLEtBQUssQ0FBQyxDQUFDO0FBQy9CLENBQUM7QUFRRCxTQUFTLGFBQWEsQ0FDcEIsWUFBd0IsRUFDeEIsTUFBa0IsRUFDbEIsTUFBYztJQUVkLE1BQU0sR0FBRyxNQUFNLEdBQUcsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsWUFBWSxDQUFDLE1BQU0sQ0FBQyxDQUFDLENBQUMsTUFBTSxDQUFDO0lBRXJFLE1BQU0sZ0JBQWdCLEdBQUcsWUFBWSxDQUFDLEtBQUssQ0FBQyxDQUFDLEVBQUUsTUFBTSxHQUFHLE1BQU0sQ0FBQyxNQUFNLENBQUMsQ0FBQztJQUN2RSxNQUFNLHlCQUF5QixHQUFHLGdCQUFnQixDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFDOUQsTUFBTSxlQUFlLEdBQUcsTUFBTSxDQUFDLE1BQU0sR0FBRyxDQUFDLENBQUM7SUFLMUMsSUFBSSxjQUFjLEdBQUcs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cyB9IGZyb20gXCIuL19ub2RlLnRzXCI7XG5pbXBvcnQgeyBpbmRleE9mIH0gZnJvbSBcIi4uLy4uL2J5dGVzL21vZC50c1wiO1xuXG5leHBvcnQgZnVuY3Rpb24gbnVtYmVyVG9CeXRlcyhuOiBudW1iZXIpOiBVaW50OEFycmF5IHtcbiAgaWYgKG4gPT09IDApIHJldHVybiBuZXcgVWludDhBcnJheShbMF0pO1xuXG4gIGNvbnN0IGJ5dGVzID0gW107XG4gIGJ5dGVzLnVuc2hpZnQobiAmIDI1NSk7XG4gIHdoaWxlIChuID49IDI1Nikge1xuICAgIG4gPSBuID4+PiA4O1xuICAgIGJ5dGVzLnVuc2hpZnQobiAmIDI1NSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ5dGVzKTtcbn1cblxuLy8gVE9ETyhTb3JlbXdhcilcbi8vIENoZWNrIGlmIG9mZnNldCBvciBidWZmZXIgY2FuIGJlIHRyYW5zZm9ybSBpbiBvcmRlciB0byBqdXN0IHVzZSBzdGQncyBsYXN0SW5kZXhPZiBkaXJlY3RseVxuLy8gVGhpcyBpbXBsZW1lbnRhdGlvbiBkaWZmZXJzIGZyb20gc3RkJ3MgbGFzdEluZGV4T2YgaW4gdGhlIGZhY3QgdGhhdFxuLy8gaXQgYWxzbyBpbmNsdWRlcyBpdGVtcyBvdXRzaWRlIG9mIHRoZSBvZmZzZXQgYXMgbG9uZyBhcyBwYXJ0IG9mIHRoZVxuLy8gc2V0IGlzIGNvbnRhaW5lZCBpbnNpZGUgb2YgdGhlIG9mZnNldFxuLy8gUHJvYmFibHkgd2F5IHNsb3dlciB0b29cbmZ1bmN0aW9uIGZpbmRMYXN0SW5kZXgoXG4gIHRhcmdldEJ1ZmZlcjogVWludDhBcnJheSxcbiAgYnVmZmVyOiBVaW50OEFycmF5LFxuICBvZmZzZXQ6IG51bWJlcixcbikge1xuICBvZmZzZXQgPSBvZmZzZXQgPiB0YXJnZXRCdWZmZXIubGVuZ3RoID8gdGFyZ2V0QnVmZmVyLmxlbmd0aCA6IG9mZnNldDtcblxuICBjb25zdCBzZWFyY2hhYmxlQnVmZmVyID0gdGFyZ2V0QnVmZmVyLnNsaWNlKDAsIG9mZnNldCArIGJ1ZmZlci5sZW5ndGgpO1xuICBjb25zdCBzZWFyY2hhYmxlQnVmZmVyTGFzdEluZGV4ID0gc2VhcmNoYWJsZUJ1ZmZlci5sZW5ndGggLSAxO1xuICBjb25zdCBidWZmZXJMYXN0SW5kZXggPSBidWZmZXIubGVuZ3RoIC0gMTtcblxuICAvLyBJbXBvcnRhbnQgdG8ga2VlcCB0cmFjayBvZiB0aGUgbGFzdCBtYXRjaCBpbmRleCBpbiBvcmRlciB0byBiYWNrdHJhY2sgYWZ0ZXIgYW4gaW5jb21wbGV0ZSBtYXRjaFxuICAvLyBOb3QgZG9pbmcgdGhpcyB3aWxsIGNhdXNlIHRoZSBzZWFyY2ggdG8gc2tpcCBhbGwgcG9zc2libGUgbWF0Y2hlcyB0aGF0IGhhcHBlbmVkIGluIHRoZVxuICAvLyBsYXN0IG1hdGNoIHJhbmdlXG4gIGxldCBsYXN0TWF0Y2hJbmRleCA9IC0xO1xuICBsZXQgbWF0Y2hlcyA9IDA7XG4gIGxldCBpbmRleCA9IC0xO1xuICBmb3IgKGxldCB4ID0gMDsgeCA8PSBzZWFyY2hhYmxlQnVmZmVyTGFzdEluZGV4OyB4KyspIHtcbiAgICBpZiAoXG4gICAgICBzZWFyY2hhYmxlQnVmZmVyW3NlYXJjaGFibGVCdWZmZXJMYXN0SW5kZXggLSB4XSA9PT1cbiAgICAgICAgYnVmZmVyW2J1ZmZlckxhc3RJbmRleCAtIG1hdGNoZXNdXG4gICAgKSB7XG4gICAgICBpZiAobGFzdE1hdGNoSW5kZXggPT09IC0xKSB7XG4gICAgICAgIGxhc3RNYXRjaEluZGV4ID0geDtcbiAgICAgIH1cbiAgICAgIG1hdGNoZXMrKztcbiAgICB9IGVsc2Uge1xuICAgICAgbWF0Y2hlcyA9IDA7XG4gICAgICBpZiAobGFzdE1hdGNoSW5kZXggIT09IC0xKSB7XG4gICAgICAgIC8vIFJlc3RhcnQgdGhlIHNlYXJjaCByaWdodCBhZnRlciB0aGUgbGFzdCBpbmRleCB3YXMgaWdub3JlZFxuICAgICAgICB4ID0gbGFzdE1hdGNoSW5kZXggKyAxO1xuICAgICAgICBsYXN0TWF0Y2hJbmRleCA9IC0xO1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgaWYgKG1hdGNoZXMgPT09IGJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgIGluZGV4ID0geDtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIGlmIChpbmRleCA9PT0gLTEpIHJldHVybiBpbmRleDtcblxuICByZXR1cm4gc2VhcmNoYWJsZUJ1ZmZlckxhc3RJbmRleCAtIGluZGV4O1xufVxuXG4vLyBUT0RPXG4vLyBUYWtlIGVuY29kaW5nIGludG8gYWNjb3VudCB3aGVuIGV2YWx1YXRpbmcgaW5kZXhcbmZ1bmN0aW9uIGluZGV4T2ZCdWZmZXIoXG4gIHRhcmdldEJ1ZmZlcjogVWludDhBcnJheSxcbiAgYnVmZmVyOiBVaW50OEFycmF5LFxuICBieXRlT2Zmc2V0OiBudW1iZXIsXG4gIGVuY29kaW5nOiBFbmNvZGluZ3MsXG4gIGZvcndhcmREaXJlY3Rpb246IGJvb2xlYW4sXG4pIHtcbiAgaWYgKCFFbmNvZGluZ3NbZW5jb2RpbmddID09PSB1bmRlZmluZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gZW5jb2RpbmcgY29kZSAke2VuY29kaW5nfWApO1xuICB9XG5cbiAgaWYgKCFmb3J3YXJkRGlyZWN0aW9uKSB7XG4gICAgLy8gSWYgbmVnYXRpdmUgdGhlIG9mZnNldCBpcyBjYWxjdWxhdGVkIGZyb20gdGhlIGVuZCBvZiB0aGUgYnVmZmVyXG5cbiAgICBpZiAoYnl0ZU9mZnNldCA8IDApIHtcbiAgICAgIGJ5dGVPZmZzZXQgPSB0YXJnZXRCdWZmZXIubGVuZ3RoICsgYnl0ZU9mZnNldDtcbiAgICB9XG5cbiAgICBpZiAoYnVmZmVyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuIGJ5dGVPZmZzZXQgPD0gdGFyZ2V0QnVmZmVyLmxlbmd0aFxuICAgICAgICA/IGJ5dGVPZmZzZXRcbiAgICAgICAgOiB0YXJnZXRCdWZmZXIubGVuZ3RoO1xuICAgIH1cblxuICAgIHJldHVybiBmaW5kTGFzdEluZGV4KHRhcmdldEJ1ZmZlciwgYnVmZmVyLCBieXRlT2Zmc2V0KTtcbiAgfVxuXG4gIGlmIChidWZmZXIubGVuZ3RoID09PSAwKSB7XG4gICAgcmV0dXJuIGJ5dGVPZmZzZXQgPD0gdGFyZ2V0QnVmZmVyLmxlbmd0aCA/IGJ5dGVPZmZzZXQgOiB0YXJnZXRCdWZmZXIubGVuZ3RoO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4T2YodGFyZ2V0QnVmZmVyLCBidWZmZXIsIGJ5dGVPZmZzZXQpO1xufVxuXG4vLyBUT0RPKFNvcmVtd2FyKVxuLy8gTm9kZSdzIGltcGxlbWVudGF0aW9uIGlzIGEgdmVyeSBvYnNjdXJlIGFsZ29yaXRobSB0aGF0IEkgaGF2ZW4ndCBiZWVuIGFibGUgdG8gY3JhY2sganVzdCB5ZXRcbmZ1bmN0aW9uIGluZGV4T2ZOdW1iZXIoXG4gIHRhcmdldEJ1ZmZlcjogVWludDhBcnJheSxcbiAgbnVtYmVyOiBudW1iZXIsXG4gIGJ5dGVPZmZzZXQ6IG51bWJlcixcbiAgZm9yd2FyZERpcmVjdGlvbjogYm9vbGVhbixcbikge1xuICBjb25zdCBieXRlcyA9IG51bWJlclRvQnl0ZXMobnVtYmVyKTtcblxuICBpZiAoYnl0ZXMubGVuZ3RoID4gMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIk11bHRpIGJ5dGUgbnVtYmVyIHNlYXJjaCBpcyBub3Qgc3VwcG9ydGVkXCIpO1xuICB9XG5cbiAgcmV0dXJuIGluZGV4T2ZCdWZmZXIoXG4gICAgdGFyZ2V0QnVmZmVyLFxuICAgIG51bWJlclRvQnl0ZXMobnVtYmVyKSxcbiAgICBieXRlT2Zmc2V0LFxuICAgIEVuY29kaW5ncy5VVEY4LFxuICAgIGZvcndhcmREaXJlY3Rpb24sXG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IHsgaW5kZXhPZkJ1ZmZlciwgaW5kZXhPZk51bWJlciB9O1xuZXhwb3J0IHsgaW5kZXhPZkJ1ZmZlciwgaW5kZXhPZk51bWJlciB9O1xuIl19