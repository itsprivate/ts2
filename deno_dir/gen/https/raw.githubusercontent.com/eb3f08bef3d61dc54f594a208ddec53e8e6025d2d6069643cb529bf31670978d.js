import { template } from "./utils/template.ts";
import mapObject from "./utils/map-obj.js";
export async function parseObject(step, ctx, options) {
    const { keys: rawKeys } = options || {};
    const keys = rawKeys || [];
    if (keys.length > 0) {
        let isExists = false;
        for (const key of keys) {
            if ((key in step)) {
                isExists = true;
            }
        }
        if (!isExists) {
            return step;
        }
    }
    try {
        const returned = await mapObject(step, async (sourceKey, sourceValue) => {
            if (keys.length > 0 && keys.includes(sourceKey) === false) {
                return [sourceKey, sourceValue];
            }
            if (typeof sourceValue === "string") {
                const parsed = await template(sourceValue, {
                    ctx: ctx.public,
                });
                return [sourceKey, parsed, {
                        shouldRecurse: false,
                    }];
            }
            else {
                if (Array.isArray(sourceValue)) {
                    const finalArray = [];
                    for (let i = 0; i < sourceValue.length; i++) {
                        const item = sourceValue[i];
                        if (typeof item === "string") {
                            const parsed = await template(item, {
                                ctx: ctx.public,
                            });
                            finalArray.push(parsed);
                        }
                        else {
                            finalArray.push(item);
                        }
                    }
                    return [
                        sourceKey,
                        finalArray,
                    ];
                }
                else {
                    return [sourceKey, sourceValue];
                }
            }
        }, {
            deep: true,
        });
        return returned;
    }
    catch (e) {
        const isReferenced = e instanceof ReferenceError;
        if (isReferenced) {
            e.message = `${e.message} , Did you forget \`ctx.\` ?`;
        }
        throw e;
    }
}
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicGFyc2Utb2JqZWN0LmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXMiOlsicGFyc2Utb2JqZWN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiJBQUVBLE9BQU8sRUFBRSxRQUFRLEVBQUUsTUFBTSxxQkFBcUIsQ0FBQztBQUMvQyxPQUFPLFNBQVMsTUFBTSxvQkFBb0IsQ0FBQztBQUkzQyxNQUFNLENBQUMsS0FBSyxVQUFVLFdBQVcsQ0FDL0IsSUFBaUIsRUFDakIsR0FBWSxFQUNaLE9BQTRCO0lBRTVCLE1BQU0sRUFBRSxJQUFJLEVBQUUsT0FBTyxFQUFFLEdBQUcsT0FBTyxJQUFJLEVBQUUsQ0FBQztJQUN4QyxNQUFNLElBQUksR0FBRyxPQUFPLElBQUksRUFBRSxDQUFDO0lBRTNCLElBQUksSUFBSSxDQUFDLE1BQU0sR0FBRyxDQUFDLEVBQUU7UUFDbkIsSUFBSSxRQUFRLEdBQUcsS0FBSyxDQUFDO1FBQ3JCLEtBQUssTUFBTSxHQUFHLElBQUksSUFBSSxFQUFFO1lBQ3RCLElBQUksQ0FBQyxHQUFHLElBQUksSUFBSSxDQUFDLEVBQUU7Z0JBQ2pCLFFBQVEsR0FBRyxJQUFJLENBQUM7YUFDakI7U0FDRjtRQUNELElBQUksQ0FBQyxRQUFRLEVBQUU7WUFFYixPQUFPLElBQUksQ0FBQztTQUNiO0tBQ0Y7SUFDRCxJQUFJO1FBQ0YsTUFBTSxRQUFRLEdBQUcsTUFBTSxTQUFTLENBQzlCLElBQUksRUFDSixLQUFLLEVBQUUsU0FBaUIsRUFBRSxXQUFvQixFQUFFLEVBQUU7WUFDaEQsSUFBSSxJQUFJLENBQUMsTUFBTSxHQUFHLENBQUMsSUFBSSxJQUFJLENBQUMsUUFBUSxDQUFDLFNBQVMsQ0FBQyxLQUFLLEtBQUssRUFBRTtnQkFDekQsT0FBTyxDQUFDLFNBQVMsRUFBRSxXQUFXLENBQUMsQ0FBQzthQUNqQztZQUNELElBQUksT0FBTyxXQUFXLEtBQUssUUFBUSxFQUFFO2dCQUNuQyxNQUFNLE1BQU0sR0FBRyxNQUFNLFFBQVEsQ0FBQyxXQUFXLEVBQUU7b0JBQ3pDLEdBQUcsRUFBRSxHQUFHLENBQUMsTUFBTTtpQkFDaEIsQ0FBQyxDQUFDO2dCQUVILE9BQU8sQ0FBQyxTQUFTLEVBQUUsTUFBTSxFQUFFO3dCQUN6QixhQUFhLEVBQUUsS0FBSztxQkFDckIsQ0FBQyxDQUFDO2FBQ0o7aUJBQU07Z0JBQ0wsSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLFdBQVcsQ0FBQyxFQUFFO29CQUM5QixNQUFNLFVBQVUsR0FBRyxFQUFFLENBQUM7b0JBQ3RCLEtBQUssSUFBSSxDQUFDLEdBQUcsQ0FBQyxFQUFFLENBQUMsR0FBRyxXQUFXLENBQUMsTUFBTSxFQUFFLENBQUMsRUFBRSxFQUFFO3dCQUMzQyxNQUFNLElBQUksR0FBRyxXQUFXLENBQUMsQ0FBQyxDQUFDLENBQUM7d0JBRTVCLElBQUksT0FBTyxJQUFJLEtBQUssUUFBUSxFQUFFOzRCQUM1QixNQUFNLE1BQU0sR0FBRyxNQUFNLFFBQVEsQ0FBQyxJQUFJLEVBQUU7Z0NBQ2xDLEdBQUcsRUFBRSxHQUFHLENBQUMsTUFBTTs2QkFDaEIsQ0FBQyxDQUFDOzRCQUNILFVBQVUsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLENBQUM7eUJBQ3pCOzZCQUFNOzRCQUNMLFVBQVUsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7eUJBQ3ZCO3FCQUNGO29CQUNELE9BQU87d0JBQ0wsU0FBUzt3QkFDVCxVQUFVO3FCQUNYLENBQUM7aUJBQ0g7cUJBQU07b0JBQ0wsT0FBTyxDQUFDLFNBQVMsRUFBRSxXQUFXLENBQUMsQ0FBQztpQkFDakM7YUFDRjtRQUNILENBQUMsRUFDRDtZQUNFLElBQUksRUFBRSxJQUFJO1NBQ1gsQ0FDRixDQUFDO1FBQ0YsT0FBTyxRQUFRLENBQUM7S0FDakI7SUFBQyxPQUFPLENBQUMsRUFBRTtRQUNWLE1BQU0sWUFBWSxHQUFHLENBQUMsWUFBWSxjQUFjLENBQUM7UUFFakQsSUFBSSxZQUFZLEVBQUU7WUFDaEIsQ0FBQyxDQUFDLE9BQU8sR0FBRyxHQUFHLENBQUMsQ0FBQyxPQUFPLDhCQUE4QixDQUFDO1NBQ3hEO1FBQ0QsTUFBTSxDQUFDLENBQUM7S0FDVDtBQUNILENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBTdGVwT3B0aW9ucyB9IGZyb20gXCIuL2ludGVyZmFjZS50c1wiO1xuaW1wb3J0IHsgQ29udGV4dCB9IGZyb20gXCIuL2ludGVybmFsLWludGVyZmFjZS50c1wiO1xuaW1wb3J0IHsgdGVtcGxhdGUgfSBmcm9tIFwiLi91dGlscy90ZW1wbGF0ZS50c1wiO1xuaW1wb3J0IG1hcE9iamVjdCBmcm9tIFwiLi91dGlscy9tYXAtb2JqLmpzXCI7XG5pbnRlcmZhY2UgT2JqZWN0cGFyc2VPcHRpb25zIHtcbiAga2V5cz86IHN0cmluZ1tdO1xufVxuZXhwb3J0IGFzeW5jIGZ1bmN0aW9uIHBhcnNlT2JqZWN0KFxuICBzdGVwOiBTdGVwT3B0aW9ucyxcbiAgY3R4OiBDb250ZXh0LFxuICBvcHRpb25zPzogT2JqZWN0cGFyc2VPcHRpb25zLFxuKTogUHJvbWlzZTx1bmtub3duPiB7XG4gIGNvbnN0IHsga2V5czogcmF3S2V5cyB9ID0gb3B0aW9ucyB8fCB7fTtcbiAgY29uc3Qga2V5cyA9IHJhd0tleXMgfHwgW107XG4gIC8vIGlmIGtleXMgcHJvdmlkZWQsIGNoZWNrIGlzIGluY2x1ZGUga2V5c1xuICBpZiAoa2V5cy5sZW5ndGggPiAwKSB7XG4gICAgbGV0IGlzRXhpc3RzID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBrZXkgb2Yga2V5cykge1xuICAgICAgaWYgKChrZXkgaW4gc3RlcCkpIHtcbiAgICAgICAgaXNFeGlzdHMgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIWlzRXhpc3RzKSB7XG4gICAgICAvLyBib3RoIG5vdCBleGlzdFxuICAgICAgcmV0dXJuIHN0ZXA7XG4gICAgfVxuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcmV0dXJuZWQgPSBhd2FpdCBtYXBPYmplY3QoXG4gICAgICBzdGVwLFxuICAgICAgYXN5bmMgKHNvdXJjZUtleTogc3RyaW5nLCBzb3VyY2VWYWx1ZTogdW5rbm93bikgPT4ge1xuICAgICAgICBpZiAoa2V5cy5sZW5ndGggPiAwICYmIGtleXMuaW5jbHVkZXMoc291cmNlS2V5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICByZXR1cm4gW3NvdXJjZUtleSwgc291cmNlVmFsdWVdO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlVmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb25zdCBwYXJzZWQgPSBhd2FpdCB0ZW1wbGF0ZShzb3VyY2VWYWx1ZSwge1xuICAgICAgICAgICAgY3R4OiBjdHgucHVibGljLFxuICAgICAgICAgIH0pO1xuXG4gICAgICAgICAgcmV0dXJuIFtzb3VyY2VLZXksIHBhcnNlZCwge1xuICAgICAgICAgICAgc2hvdWxkUmVjdXJzZTogZmFsc2UsXG4gICAgICAgICAgfV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoc291cmNlVmFsdWUpKSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbEFycmF5ID0gW107XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNvdXJjZVZhbHVlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGl0ZW0gPSBzb3VyY2VWYWx1ZVtpXTtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGl0ZW0gPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWQgPSBhd2FpdCB0ZW1wbGF0ZShpdGVtLCB7XG4gICAgICAgICAgICAgICAgICBjdHg6IGN0eC5wdWJsaWMsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgZmluYWxBcnJheS5wdXNoKHBhcnNlZCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZmluYWxBcnJheS5wdXNoKGl0ZW0pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICBzb3VyY2VLZXksXG4gICAgICAgICAgICAgIGZpbmFsQXJyYXksXG4gICAgICAgICAgICBdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gW3NvdXJjZUtleSwgc291cmNlVmFsdWVdO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHtcbiAgICAgICAgZGVlcDogdHJ1ZSxcbiAgICAgIH0sXG4gICAgKTtcbiAgICByZXR1cm4gcmV0dXJuZWQ7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICBjb25zdCBpc1JlZmVyZW5jZWQgPSBlIGluc3RhbmNlb2YgUmVmZXJlbmNlRXJyb3I7XG5cbiAgICBpZiAoaXNSZWZlcmVuY2VkKSB7XG4gICAgICBlLm1lc3NhZ2UgPSBgJHtlLm1lc3NhZ2V9ICwgRGlkIHlvdSBmb3JnZXQgXFxgY3R4LlxcYCA/YDtcbiAgICB9XG4gICAgdGhyb3cgZTtcbiAgfVxufVxuIl19